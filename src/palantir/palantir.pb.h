// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: palantir.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_palantir_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_palantir_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_palantir_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_palantir_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_palantir_2eproto;
namespace palantir {
class Cancel;
struct CancelDefaultTypeInternal;
extern CancelDefaultTypeInternal _Cancel_default_instance_;
class Capabilities;
struct CapabilitiesDefaultTypeInternal;
extern CapabilitiesDefaultTypeInternal _Capabilities_default_instance_;
class CapabilitiesRequest;
struct CapabilitiesRequestDefaultTypeInternal;
extern CapabilitiesRequestDefaultTypeInternal _CapabilitiesRequest_default_instance_;
class ComputeSpec;
struct ComputeSpecDefaultTypeInternal;
extern ComputeSpecDefaultTypeInternal _ComputeSpec_default_instance_;
class ComputeSpec_ParamsEntry_DoNotUse;
struct ComputeSpec_ParamsEntry_DoNotUseDefaultTypeInternal;
extern ComputeSpec_ParamsEntry_DoNotUseDefaultTypeInternal _ComputeSpec_ParamsEntry_DoNotUse_default_instance_;
class DataChunk;
struct DataChunkDefaultTypeInternal;
extern DataChunkDefaultTypeInternal _DataChunk_default_instance_;
class JobId;
struct JobIdDefaultTypeInternal;
extern JobIdDefaultTypeInternal _JobId_default_instance_;
class Pong;
struct PongDefaultTypeInternal;
extern PongDefaultTypeInternal _Pong_default_instance_;
class Progress;
struct ProgressDefaultTypeInternal;
extern ProgressDefaultTypeInternal _Progress_default_instance_;
class ResultMeta;
struct ResultMetaDefaultTypeInternal;
extern ResultMetaDefaultTypeInternal _ResultMeta_default_instance_;
class StartJob;
struct StartJobDefaultTypeInternal;
extern StartJobDefaultTypeInternal _StartJob_default_instance_;
class StartReply;
struct StartReplyDefaultTypeInternal;
extern StartReplyDefaultTypeInternal _StartReply_default_instance_;
class XYSineResult;
struct XYSineResultDefaultTypeInternal;
extern XYSineResultDefaultTypeInternal _XYSineResult_default_instance_;
class XYSineSpec;
struct XYSineSpecDefaultTypeInternal;
extern XYSineSpecDefaultTypeInternal _XYSineSpec_default_instance_;
}  // namespace palantir
PROTOBUF_NAMESPACE_OPEN
template<> ::palantir::Cancel* Arena::CreateMaybeMessage<::palantir::Cancel>(Arena*);
template<> ::palantir::Capabilities* Arena::CreateMaybeMessage<::palantir::Capabilities>(Arena*);
template<> ::palantir::CapabilitiesRequest* Arena::CreateMaybeMessage<::palantir::CapabilitiesRequest>(Arena*);
template<> ::palantir::ComputeSpec* Arena::CreateMaybeMessage<::palantir::ComputeSpec>(Arena*);
template<> ::palantir::ComputeSpec_ParamsEntry_DoNotUse* Arena::CreateMaybeMessage<::palantir::ComputeSpec_ParamsEntry_DoNotUse>(Arena*);
template<> ::palantir::DataChunk* Arena::CreateMaybeMessage<::palantir::DataChunk>(Arena*);
template<> ::palantir::JobId* Arena::CreateMaybeMessage<::palantir::JobId>(Arena*);
template<> ::palantir::Pong* Arena::CreateMaybeMessage<::palantir::Pong>(Arena*);
template<> ::palantir::Progress* Arena::CreateMaybeMessage<::palantir::Progress>(Arena*);
template<> ::palantir::ResultMeta* Arena::CreateMaybeMessage<::palantir::ResultMeta>(Arena*);
template<> ::palantir::StartJob* Arena::CreateMaybeMessage<::palantir::StartJob>(Arena*);
template<> ::palantir::StartReply* Arena::CreateMaybeMessage<::palantir::StartReply>(Arena*);
template<> ::palantir::XYSineResult* Arena::CreateMaybeMessage<::palantir::XYSineResult>(Arena*);
template<> ::palantir::XYSineSpec* Arena::CreateMaybeMessage<::palantir::XYSineSpec>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace palantir {

// ===================================================================

class JobId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palantir.JobId) */ {
 public:
  inline JobId() : JobId(nullptr) {}
  ~JobId() override;
  explicit constexpr JobId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JobId(const JobId& from);
  JobId(JobId&& from) noexcept
    : JobId() {
    *this = ::std::move(from);
  }

  inline JobId& operator=(const JobId& from) {
    CopyFrom(from);
    return *this;
  }
  inline JobId& operator=(JobId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JobId& default_instance() {
    return *internal_default_instance();
  }
  static inline const JobId* internal_default_instance() {
    return reinterpret_cast<const JobId*>(
               &_JobId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(JobId& a, JobId& b) {
    a.Swap(&b);
  }
  inline void Swap(JobId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JobId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JobId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JobId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JobId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const JobId& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JobId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palantir.JobId";
  }
  protected:
  explicit JobId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:palantir.JobId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_palantir_2eproto;
};
// -------------------------------------------------------------------

class ComputeSpec_ParamsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ComputeSpec_ParamsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ComputeSpec_ParamsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ComputeSpec_ParamsEntry_DoNotUse();
  explicit constexpr ComputeSpec_ParamsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ComputeSpec_ParamsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ComputeSpec_ParamsEntry_DoNotUse& other);
  static const ComputeSpec_ParamsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ComputeSpec_ParamsEntry_DoNotUse*>(&_ComputeSpec_ParamsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "palantir.ComputeSpec.ParamsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "palantir.ComputeSpec.ParamsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class ComputeSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palantir.ComputeSpec) */ {
 public:
  inline ComputeSpec() : ComputeSpec(nullptr) {}
  ~ComputeSpec() override;
  explicit constexpr ComputeSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ComputeSpec(const ComputeSpec& from);
  ComputeSpec(ComputeSpec&& from) noexcept
    : ComputeSpec() {
    *this = ::std::move(from);
  }

  inline ComputeSpec& operator=(const ComputeSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComputeSpec& operator=(ComputeSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ComputeSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const ComputeSpec* internal_default_instance() {
    return reinterpret_cast<const ComputeSpec*>(
               &_ComputeSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ComputeSpec& a, ComputeSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(ComputeSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComputeSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ComputeSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ComputeSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ComputeSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ComputeSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ComputeSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palantir.ComputeSpec";
  }
  protected:
  explicit ComputeSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParamsFieldNumber = 2,
    kFeatureIdFieldNumber = 1,
    kDeadlineMsFieldNumber = 3,
    kProduceDebugFieldNumber = 4,
  };
  // map<string, string> params = 2;
  int params_size() const;
  private:
  int _internal_params_size() const;
  public:
  void clear_params();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_params() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_params();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      params() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_params();

  // string feature_id = 1;
  void clear_feature_id();
  const std::string& feature_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_feature_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_feature_id();
  PROTOBUF_NODISCARD std::string* release_feature_id();
  void set_allocated_feature_id(std::string* feature_id);
  private:
  const std::string& _internal_feature_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_feature_id(const std::string& value);
  std::string* _internal_mutable_feature_id();
  public:

  // optional int32 deadline_ms = 3;
  bool has_deadline_ms() const;
  private:
  bool _internal_has_deadline_ms() const;
  public:
  void clear_deadline_ms();
  int32_t deadline_ms() const;
  void set_deadline_ms(int32_t value);
  private:
  int32_t _internal_deadline_ms() const;
  void _internal_set_deadline_ms(int32_t value);
  public:

  // optional bool produce_debug = 4;
  bool has_produce_debug() const;
  private:
  bool _internal_has_produce_debug() const;
  public:
  void clear_produce_debug();
  bool produce_debug() const;
  void set_produce_debug(bool value);
  private:
  bool _internal_produce_debug() const;
  void _internal_set_produce_debug(bool value);
  public:

  // @@protoc_insertion_point(class_scope:palantir.ComputeSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ComputeSpec_ParamsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> params_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr feature_id_;
  int32_t deadline_ms_;
  bool produce_debug_;
  friend struct ::TableStruct_palantir_2eproto;
};
// -------------------------------------------------------------------

class StartReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palantir.StartReply) */ {
 public:
  inline StartReply() : StartReply(nullptr) {}
  ~StartReply() override;
  explicit constexpr StartReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartReply(const StartReply& from);
  StartReply(StartReply&& from) noexcept
    : StartReply() {
    *this = ::std::move(from);
  }

  inline StartReply& operator=(const StartReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartReply& operator=(StartReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartReply* internal_default_instance() {
    return reinterpret_cast<const StartReply*>(
               &_StartReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(StartReply& a, StartReply& b) {
    a.Swap(&b);
  }
  inline void Swap(StartReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StartReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palantir.StartReply";
  }
  protected:
  explicit StartReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kErrorMessageFieldNumber = 3,
    kJobIdFieldNumber = 1,
  };
  // string status = 2;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // optional string error_message = 3;
  bool has_error_message() const;
  private:
  bool _internal_has_error_message() const;
  public:
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .palantir.JobId job_id = 1;
  bool has_job_id() const;
  private:
  bool _internal_has_job_id() const;
  public:
  void clear_job_id();
  const ::palantir::JobId& job_id() const;
  PROTOBUF_NODISCARD ::palantir::JobId* release_job_id();
  ::palantir::JobId* mutable_job_id();
  void set_allocated_job_id(::palantir::JobId* job_id);
  private:
  const ::palantir::JobId& _internal_job_id() const;
  ::palantir::JobId* _internal_mutable_job_id();
  public:
  void unsafe_arena_set_allocated_job_id(
      ::palantir::JobId* job_id);
  ::palantir::JobId* unsafe_arena_release_job_id();

  // @@protoc_insertion_point(class_scope:palantir.StartReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  ::palantir::JobId* job_id_;
  friend struct ::TableStruct_palantir_2eproto;
};
// -------------------------------------------------------------------

class Progress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palantir.Progress) */ {
 public:
  inline Progress() : Progress(nullptr) {}
  ~Progress() override;
  explicit constexpr Progress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Progress(const Progress& from);
  Progress(Progress&& from) noexcept
    : Progress() {
    *this = ::std::move(from);
  }

  inline Progress& operator=(const Progress& from) {
    CopyFrom(from);
    return *this;
  }
  inline Progress& operator=(Progress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Progress& default_instance() {
    return *internal_default_instance();
  }
  static inline const Progress* internal_default_instance() {
    return reinterpret_cast<const Progress*>(
               &_Progress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Progress& a, Progress& b) {
    a.Swap(&b);
  }
  inline void Swap(Progress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Progress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Progress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Progress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Progress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Progress& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Progress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palantir.Progress";
  }
  protected:
  explicit Progress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 3,
    kMessageFieldNumber = 4,
    kJobIdFieldNumber = 1,
    kProgressPctFieldNumber = 2,
  };
  // string status = 3;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // optional string message = 4;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .palantir.JobId job_id = 1;
  bool has_job_id() const;
  private:
  bool _internal_has_job_id() const;
  public:
  void clear_job_id();
  const ::palantir::JobId& job_id() const;
  PROTOBUF_NODISCARD ::palantir::JobId* release_job_id();
  ::palantir::JobId* mutable_job_id();
  void set_allocated_job_id(::palantir::JobId* job_id);
  private:
  const ::palantir::JobId& _internal_job_id() const;
  ::palantir::JobId* _internal_mutable_job_id();
  public:
  void unsafe_arena_set_allocated_job_id(
      ::palantir::JobId* job_id);
  ::palantir::JobId* unsafe_arena_release_job_id();

  // double progress_pct = 2;
  void clear_progress_pct();
  double progress_pct() const;
  void set_progress_pct(double value);
  private:
  double _internal_progress_pct() const;
  void _internal_set_progress_pct(double value);
  public:

  // @@protoc_insertion_point(class_scope:palantir.Progress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::palantir::JobId* job_id_;
  double progress_pct_;
  friend struct ::TableStruct_palantir_2eproto;
};
// -------------------------------------------------------------------

class ResultMeta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palantir.ResultMeta) */ {
 public:
  inline ResultMeta() : ResultMeta(nullptr) {}
  ~ResultMeta() override;
  explicit constexpr ResultMeta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResultMeta(const ResultMeta& from);
  ResultMeta(ResultMeta&& from) noexcept
    : ResultMeta() {
    *this = ::std::move(from);
  }

  inline ResultMeta& operator=(const ResultMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResultMeta& operator=(ResultMeta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResultMeta& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResultMeta* internal_default_instance() {
    return reinterpret_cast<const ResultMeta*>(
               &_ResultMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ResultMeta& a, ResultMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(ResultMeta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResultMeta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResultMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResultMeta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResultMeta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResultMeta& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResultMeta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palantir.ResultMeta";
  }
  protected:
  explicit ResultMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapeFieldNumber = 4,
    kLabelsFieldNumber = 7,
    kStatusFieldNumber = 2,
    kDtypeFieldNumber = 3,
    kErrorMessageFieldNumber = 8,
    kJobIdFieldNumber = 1,
    kComputeElapsedMsFieldNumber = 5,
    kBytesTotalFieldNumber = 6,
  };
  // repeated int32 shape = 4;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  private:
  int32_t _internal_shape(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_shape() const;
  void _internal_add_shape(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_shape();
  public:
  int32_t shape(int index) const;
  void set_shape(int index, int32_t value);
  void add_shape(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      shape() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_shape();

  // repeated string labels = 7;
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  const std::string& labels(int index) const;
  std::string* mutable_labels(int index);
  void set_labels(int index, const std::string& value);
  void set_labels(int index, std::string&& value);
  void set_labels(int index, const char* value);
  void set_labels(int index, const char* value, size_t size);
  std::string* add_labels();
  void add_labels(const std::string& value);
  void add_labels(std::string&& value);
  void add_labels(const char* value);
  void add_labels(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& labels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_labels();
  private:
  const std::string& _internal_labels(int index) const;
  std::string* _internal_add_labels();
  public:

  // string status = 2;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // string dtype = 3;
  void clear_dtype();
  const std::string& dtype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dtype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dtype();
  PROTOBUF_NODISCARD std::string* release_dtype();
  void set_allocated_dtype(std::string* dtype);
  private:
  const std::string& _internal_dtype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dtype(const std::string& value);
  std::string* _internal_mutable_dtype();
  public:

  // optional string error_message = 8;
  bool has_error_message() const;
  private:
  bool _internal_has_error_message() const;
  public:
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .palantir.JobId job_id = 1;
  bool has_job_id() const;
  private:
  bool _internal_has_job_id() const;
  public:
  void clear_job_id();
  const ::palantir::JobId& job_id() const;
  PROTOBUF_NODISCARD ::palantir::JobId* release_job_id();
  ::palantir::JobId* mutable_job_id();
  void set_allocated_job_id(::palantir::JobId* job_id);
  private:
  const ::palantir::JobId& _internal_job_id() const;
  ::palantir::JobId* _internal_mutable_job_id();
  public:
  void unsafe_arena_set_allocated_job_id(
      ::palantir::JobId* job_id);
  ::palantir::JobId* unsafe_arena_release_job_id();

  // int64 compute_elapsed_ms = 5;
  void clear_compute_elapsed_ms();
  int64_t compute_elapsed_ms() const;
  void set_compute_elapsed_ms(int64_t value);
  private:
  int64_t _internal_compute_elapsed_ms() const;
  void _internal_set_compute_elapsed_ms(int64_t value);
  public:

  // int64 bytes_total = 6;
  void clear_bytes_total();
  int64_t bytes_total() const;
  void set_bytes_total(int64_t value);
  private:
  int64_t _internal_bytes_total() const;
  void _internal_set_bytes_total(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:palantir.ResultMeta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > shape_;
  mutable std::atomic<int> _shape_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> labels_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dtype_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  ::palantir::JobId* job_id_;
  int64_t compute_elapsed_ms_;
  int64_t bytes_total_;
  friend struct ::TableStruct_palantir_2eproto;
};
// -------------------------------------------------------------------

class DataChunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palantir.DataChunk) */ {
 public:
  inline DataChunk() : DataChunk(nullptr) {}
  ~DataChunk() override;
  explicit constexpr DataChunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataChunk(const DataChunk& from);
  DataChunk(DataChunk&& from) noexcept
    : DataChunk() {
    *this = ::std::move(from);
  }

  inline DataChunk& operator=(const DataChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataChunk& operator=(DataChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataChunk* internal_default_instance() {
    return reinterpret_cast<const DataChunk*>(
               &_DataChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DataChunk& a, DataChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(DataChunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataChunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataChunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataChunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DataChunk& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataChunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palantir.DataChunk";
  }
  protected:
  explicit DataChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 4,
    kJobIdFieldNumber = 1,
    kChunkIndexFieldNumber = 2,
    kTotalChunksFieldNumber = 3,
  };
  // bytes data = 4;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .palantir.JobId job_id = 1;
  bool has_job_id() const;
  private:
  bool _internal_has_job_id() const;
  public:
  void clear_job_id();
  const ::palantir::JobId& job_id() const;
  PROTOBUF_NODISCARD ::palantir::JobId* release_job_id();
  ::palantir::JobId* mutable_job_id();
  void set_allocated_job_id(::palantir::JobId* job_id);
  private:
  const ::palantir::JobId& _internal_job_id() const;
  ::palantir::JobId* _internal_mutable_job_id();
  public:
  void unsafe_arena_set_allocated_job_id(
      ::palantir::JobId* job_id);
  ::palantir::JobId* unsafe_arena_release_job_id();

  // int32 chunk_index = 2;
  void clear_chunk_index();
  int32_t chunk_index() const;
  void set_chunk_index(int32_t value);
  private:
  int32_t _internal_chunk_index() const;
  void _internal_set_chunk_index(int32_t value);
  public:

  // int32 total_chunks = 3;
  void clear_total_chunks();
  int32_t total_chunks() const;
  void set_total_chunks(int32_t value);
  private:
  int32_t _internal_total_chunks() const;
  void _internal_set_total_chunks(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:palantir.DataChunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::palantir::JobId* job_id_;
  int32_t chunk_index_;
  int32_t total_chunks_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_palantir_2eproto;
};
// -------------------------------------------------------------------

class Cancel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palantir.Cancel) */ {
 public:
  inline Cancel() : Cancel(nullptr) {}
  ~Cancel() override;
  explicit constexpr Cancel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Cancel(const Cancel& from);
  Cancel(Cancel&& from) noexcept
    : Cancel() {
    *this = ::std::move(from);
  }

  inline Cancel& operator=(const Cancel& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cancel& operator=(Cancel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Cancel& default_instance() {
    return *internal_default_instance();
  }
  static inline const Cancel* internal_default_instance() {
    return reinterpret_cast<const Cancel*>(
               &_Cancel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Cancel& a, Cancel& b) {
    a.Swap(&b);
  }
  inline void Swap(Cancel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Cancel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Cancel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Cancel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Cancel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Cancel& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cancel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palantir.Cancel";
  }
  protected:
  explicit Cancel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobIdFieldNumber = 1,
  };
  // .palantir.JobId job_id = 1;
  bool has_job_id() const;
  private:
  bool _internal_has_job_id() const;
  public:
  void clear_job_id();
  const ::palantir::JobId& job_id() const;
  PROTOBUF_NODISCARD ::palantir::JobId* release_job_id();
  ::palantir::JobId* mutable_job_id();
  void set_allocated_job_id(::palantir::JobId* job_id);
  private:
  const ::palantir::JobId& _internal_job_id() const;
  ::palantir::JobId* _internal_mutable_job_id();
  public:
  void unsafe_arena_set_allocated_job_id(
      ::palantir::JobId* job_id);
  ::palantir::JobId* unsafe_arena_release_job_id();

  // @@protoc_insertion_point(class_scope:palantir.Cancel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::palantir::JobId* job_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_palantir_2eproto;
};
// -------------------------------------------------------------------

class StartJob final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palantir.StartJob) */ {
 public:
  inline StartJob() : StartJob(nullptr) {}
  ~StartJob() override;
  explicit constexpr StartJob(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartJob(const StartJob& from);
  StartJob(StartJob&& from) noexcept
    : StartJob() {
    *this = ::std::move(from);
  }

  inline StartJob& operator=(const StartJob& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartJob& operator=(StartJob&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartJob& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartJob* internal_default_instance() {
    return reinterpret_cast<const StartJob*>(
               &_StartJob_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StartJob& a, StartJob& b) {
    a.Swap(&b);
  }
  inline void Swap(StartJob* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartJob* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartJob* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartJob>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartJob& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StartJob& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartJob* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palantir.StartJob";
  }
  protected:
  explicit StartJob(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobIdFieldNumber = 1,
    kSpecFieldNumber = 2,
  };
  // .palantir.JobId job_id = 1;
  bool has_job_id() const;
  private:
  bool _internal_has_job_id() const;
  public:
  void clear_job_id();
  const ::palantir::JobId& job_id() const;
  PROTOBUF_NODISCARD ::palantir::JobId* release_job_id();
  ::palantir::JobId* mutable_job_id();
  void set_allocated_job_id(::palantir::JobId* job_id);
  private:
  const ::palantir::JobId& _internal_job_id() const;
  ::palantir::JobId* _internal_mutable_job_id();
  public:
  void unsafe_arena_set_allocated_job_id(
      ::palantir::JobId* job_id);
  ::palantir::JobId* unsafe_arena_release_job_id();

  // .palantir.ComputeSpec spec = 2;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::palantir::ComputeSpec& spec() const;
  PROTOBUF_NODISCARD ::palantir::ComputeSpec* release_spec();
  ::palantir::ComputeSpec* mutable_spec();
  void set_allocated_spec(::palantir::ComputeSpec* spec);
  private:
  const ::palantir::ComputeSpec& _internal_spec() const;
  ::palantir::ComputeSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::palantir::ComputeSpec* spec);
  ::palantir::ComputeSpec* unsafe_arena_release_spec();

  // @@protoc_insertion_point(class_scope:palantir.StartJob)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::palantir::JobId* job_id_;
  ::palantir::ComputeSpec* spec_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_palantir_2eproto;
};
// -------------------------------------------------------------------

class CapabilitiesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:palantir.CapabilitiesRequest) */ {
 public:
  inline CapabilitiesRequest() : CapabilitiesRequest(nullptr) {}
  explicit constexpr CapabilitiesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CapabilitiesRequest(const CapabilitiesRequest& from);
  CapabilitiesRequest(CapabilitiesRequest&& from) noexcept
    : CapabilitiesRequest() {
    *this = ::std::move(from);
  }

  inline CapabilitiesRequest& operator=(const CapabilitiesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CapabilitiesRequest& operator=(CapabilitiesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CapabilitiesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CapabilitiesRequest* internal_default_instance() {
    return reinterpret_cast<const CapabilitiesRequest*>(
               &_CapabilitiesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CapabilitiesRequest& a, CapabilitiesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CapabilitiesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CapabilitiesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CapabilitiesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CapabilitiesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CapabilitiesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CapabilitiesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palantir.CapabilitiesRequest";
  }
  protected:
  explicit CapabilitiesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:palantir.CapabilitiesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_palantir_2eproto;
};
// -------------------------------------------------------------------

class Capabilities final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palantir.Capabilities) */ {
 public:
  inline Capabilities() : Capabilities(nullptr) {}
  ~Capabilities() override;
  explicit constexpr Capabilities(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Capabilities(const Capabilities& from);
  Capabilities(Capabilities&& from) noexcept
    : Capabilities() {
    *this = ::std::move(from);
  }

  inline Capabilities& operator=(const Capabilities& from) {
    CopyFrom(from);
    return *this;
  }
  inline Capabilities& operator=(Capabilities&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Capabilities& default_instance() {
    return *internal_default_instance();
  }
  static inline const Capabilities* internal_default_instance() {
    return reinterpret_cast<const Capabilities*>(
               &_Capabilities_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Capabilities& a, Capabilities& b) {
    a.Swap(&b);
  }
  inline void Swap(Capabilities* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Capabilities* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Capabilities* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Capabilities>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Capabilities& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Capabilities& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Capabilities* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palantir.Capabilities";
  }
  protected:
  explicit Capabilities(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSupportedFeaturesFieldNumber = 2,
    kProtocolVersionFieldNumber = 3,
    kMaxConcurrencyFieldNumber = 1,
  };
  // repeated string supported_features = 2;
  int supported_features_size() const;
  private:
  int _internal_supported_features_size() const;
  public:
  void clear_supported_features();
  const std::string& supported_features(int index) const;
  std::string* mutable_supported_features(int index);
  void set_supported_features(int index, const std::string& value);
  void set_supported_features(int index, std::string&& value);
  void set_supported_features(int index, const char* value);
  void set_supported_features(int index, const char* value, size_t size);
  std::string* add_supported_features();
  void add_supported_features(const std::string& value);
  void add_supported_features(std::string&& value);
  void add_supported_features(const char* value);
  void add_supported_features(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& supported_features() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_supported_features();
  private:
  const std::string& _internal_supported_features(int index) const;
  std::string* _internal_add_supported_features();
  public:

  // string protocol_version = 3;
  void clear_protocol_version();
  const std::string& protocol_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_protocol_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_protocol_version();
  PROTOBUF_NODISCARD std::string* release_protocol_version();
  void set_allocated_protocol_version(std::string* protocol_version);
  private:
  const std::string& _internal_protocol_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_protocol_version(const std::string& value);
  std::string* _internal_mutable_protocol_version();
  public:

  // int32 max_concurrency = 1;
  void clear_max_concurrency();
  int32_t max_concurrency() const;
  void set_max_concurrency(int32_t value);
  private:
  int32_t _internal_max_concurrency() const;
  void _internal_set_max_concurrency(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:palantir.Capabilities)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> supported_features_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr protocol_version_;
  int32_t max_concurrency_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_palantir_2eproto;
};
// -------------------------------------------------------------------

class Pong final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palantir.Pong) */ {
 public:
  inline Pong() : Pong(nullptr) {}
  ~Pong() override;
  explicit constexpr Pong(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Pong(const Pong& from);
  Pong(Pong&& from) noexcept
    : Pong() {
    *this = ::std::move(from);
  }

  inline Pong& operator=(const Pong& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pong& operator=(Pong&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pong& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pong* internal_default_instance() {
    return reinterpret_cast<const Pong*>(
               &_Pong_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Pong& a, Pong& b) {
    a.Swap(&b);
  }
  inline void Swap(Pong* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pong* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pong* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pong>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Pong& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Pong& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pong* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palantir.Pong";
  }
  protected:
  explicit Pong(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampMsFieldNumber = 1,
  };
  // int64 timestamp_ms = 1;
  void clear_timestamp_ms();
  int64_t timestamp_ms() const;
  void set_timestamp_ms(int64_t value);
  private:
  int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:palantir.Pong)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t timestamp_ms_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_palantir_2eproto;
};
// -------------------------------------------------------------------

class XYSineSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palantir.XYSineSpec) */ {
 public:
  inline XYSineSpec() : XYSineSpec(nullptr) {}
  ~XYSineSpec() override;
  explicit constexpr XYSineSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  XYSineSpec(const XYSineSpec& from);
  XYSineSpec(XYSineSpec&& from) noexcept
    : XYSineSpec() {
    *this = ::std::move(from);
  }

  inline XYSineSpec& operator=(const XYSineSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline XYSineSpec& operator=(XYSineSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const XYSineSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const XYSineSpec* internal_default_instance() {
    return reinterpret_cast<const XYSineSpec*>(
               &_XYSineSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(XYSineSpec& a, XYSineSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(XYSineSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(XYSineSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  XYSineSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<XYSineSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const XYSineSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const XYSineSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XYSineSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palantir.XYSineSpec";
  }
  protected:
  explicit XYSineSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAmplitudeFieldNumber = 1,
    kFrequencyFieldNumber = 2,
    kPhaseFieldNumber = 3,
    kCyclesFieldNumber = 4,
    kNSamplesFieldNumber = 5,
  };
  // double amplitude = 1;
  void clear_amplitude();
  double amplitude() const;
  void set_amplitude(double value);
  private:
  double _internal_amplitude() const;
  void _internal_set_amplitude(double value);
  public:

  // double frequency = 2;
  void clear_frequency();
  double frequency() const;
  void set_frequency(double value);
  private:
  double _internal_frequency() const;
  void _internal_set_frequency(double value);
  public:

  // double phase = 3;
  void clear_phase();
  double phase() const;
  void set_phase(double value);
  private:
  double _internal_phase() const;
  void _internal_set_phase(double value);
  public:

  // int32 cycles = 4;
  void clear_cycles();
  int32_t cycles() const;
  void set_cycles(int32_t value);
  private:
  int32_t _internal_cycles() const;
  void _internal_set_cycles(int32_t value);
  public:

  // int32 n_samples = 5;
  void clear_n_samples();
  int32_t n_samples() const;
  void set_n_samples(int32_t value);
  private:
  int32_t _internal_n_samples() const;
  void _internal_set_n_samples(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:palantir.XYSineSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double amplitude_;
  double frequency_;
  double phase_;
  int32_t cycles_;
  int32_t n_samples_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_palantir_2eproto;
};
// -------------------------------------------------------------------

class XYSineResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palantir.XYSineResult) */ {
 public:
  inline XYSineResult() : XYSineResult(nullptr) {}
  ~XYSineResult() override;
  explicit constexpr XYSineResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  XYSineResult(const XYSineResult& from);
  XYSineResult(XYSineResult&& from) noexcept
    : XYSineResult() {
    *this = ::std::move(from);
  }

  inline XYSineResult& operator=(const XYSineResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline XYSineResult& operator=(XYSineResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const XYSineResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const XYSineResult* internal_default_instance() {
    return reinterpret_cast<const XYSineResult*>(
               &_XYSineResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(XYSineResult& a, XYSineResult& b) {
    a.Swap(&b);
  }
  inline void Swap(XYSineResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(XYSineResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  XYSineResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<XYSineResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const XYSineResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const XYSineResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XYSineResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palantir.XYSineResult";
  }
  protected:
  explicit XYSineResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXValuesFieldNumber = 1,
    kYValuesFieldNumber = 2,
    kSeriesPointsFieldNumber = 3,
    kSeriesPointsEffectiveFieldNumber = 4,
    kDownsamplingEnabledFieldNumber = 5,
  };
  // repeated double x_values = 1;
  int x_values_size() const;
  private:
  int _internal_x_values_size() const;
  public:
  void clear_x_values();
  private:
  double _internal_x_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_x_values() const;
  void _internal_add_x_values(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_x_values();
  public:
  double x_values(int index) const;
  void set_x_values(int index, double value);
  void add_x_values(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      x_values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_x_values();

  // repeated double y_values = 2;
  int y_values_size() const;
  private:
  int _internal_y_values_size() const;
  public:
  void clear_y_values();
  private:
  double _internal_y_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_y_values() const;
  void _internal_add_y_values(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_y_values();
  public:
  double y_values(int index) const;
  void set_y_values(int index, double value);
  void add_y_values(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      y_values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_y_values();

  // int32 series_points = 3;
  void clear_series_points();
  int32_t series_points() const;
  void set_series_points(int32_t value);
  private:
  int32_t _internal_series_points() const;
  void _internal_set_series_points(int32_t value);
  public:

  // int32 series_points_effective = 4;
  void clear_series_points_effective();
  int32_t series_points_effective() const;
  void set_series_points_effective(int32_t value);
  private:
  int32_t _internal_series_points_effective() const;
  void _internal_set_series_points_effective(int32_t value);
  public:

  // bool downsampling_enabled = 5;
  void clear_downsampling_enabled();
  bool downsampling_enabled() const;
  void set_downsampling_enabled(bool value);
  private:
  bool _internal_downsampling_enabled() const;
  void _internal_set_downsampling_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:palantir.XYSineResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > x_values_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > y_values_;
  int32_t series_points_;
  int32_t series_points_effective_;
  bool downsampling_enabled_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_palantir_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// JobId

// string id = 1;
inline void JobId::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& JobId::id() const {
  // @@protoc_insertion_point(field_get:palantir.JobId.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobId::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palantir.JobId.id)
}
inline std::string* JobId::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:palantir.JobId.id)
  return _s;
}
inline const std::string& JobId::_internal_id() const {
  return id_.Get();
}
inline void JobId::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* JobId::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* JobId::release_id() {
  // @@protoc_insertion_point(field_release:palantir.JobId.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void JobId::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palantir.JobId.id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ComputeSpec

// string feature_id = 1;
inline void ComputeSpec::clear_feature_id() {
  feature_id_.ClearToEmpty();
}
inline const std::string& ComputeSpec::feature_id() const {
  // @@protoc_insertion_point(field_get:palantir.ComputeSpec.feature_id)
  return _internal_feature_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ComputeSpec::set_feature_id(ArgT0&& arg0, ArgT... args) {
 
 feature_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palantir.ComputeSpec.feature_id)
}
inline std::string* ComputeSpec::mutable_feature_id() {
  std::string* _s = _internal_mutable_feature_id();
  // @@protoc_insertion_point(field_mutable:palantir.ComputeSpec.feature_id)
  return _s;
}
inline const std::string& ComputeSpec::_internal_feature_id() const {
  return feature_id_.Get();
}
inline void ComputeSpec::_internal_set_feature_id(const std::string& value) {
  
  feature_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ComputeSpec::_internal_mutable_feature_id() {
  
  return feature_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ComputeSpec::release_feature_id() {
  // @@protoc_insertion_point(field_release:palantir.ComputeSpec.feature_id)
  return feature_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ComputeSpec::set_allocated_feature_id(std::string* feature_id) {
  if (feature_id != nullptr) {
    
  } else {
    
  }
  feature_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), feature_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (feature_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    feature_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palantir.ComputeSpec.feature_id)
}

// map<string, string> params = 2;
inline int ComputeSpec::_internal_params_size() const {
  return params_.size();
}
inline int ComputeSpec::params_size() const {
  return _internal_params_size();
}
inline void ComputeSpec::clear_params() {
  params_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ComputeSpec::_internal_params() const {
  return params_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ComputeSpec::params() const {
  // @@protoc_insertion_point(field_map:palantir.ComputeSpec.params)
  return _internal_params();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ComputeSpec::_internal_mutable_params() {
  return params_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ComputeSpec::mutable_params() {
  // @@protoc_insertion_point(field_mutable_map:palantir.ComputeSpec.params)
  return _internal_mutable_params();
}

// optional int32 deadline_ms = 3;
inline bool ComputeSpec::_internal_has_deadline_ms() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ComputeSpec::has_deadline_ms() const {
  return _internal_has_deadline_ms();
}
inline void ComputeSpec::clear_deadline_ms() {
  deadline_ms_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t ComputeSpec::_internal_deadline_ms() const {
  return deadline_ms_;
}
inline int32_t ComputeSpec::deadline_ms() const {
  // @@protoc_insertion_point(field_get:palantir.ComputeSpec.deadline_ms)
  return _internal_deadline_ms();
}
inline void ComputeSpec::_internal_set_deadline_ms(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  deadline_ms_ = value;
}
inline void ComputeSpec::set_deadline_ms(int32_t value) {
  _internal_set_deadline_ms(value);
  // @@protoc_insertion_point(field_set:palantir.ComputeSpec.deadline_ms)
}

// optional bool produce_debug = 4;
inline bool ComputeSpec::_internal_has_produce_debug() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ComputeSpec::has_produce_debug() const {
  return _internal_has_produce_debug();
}
inline void ComputeSpec::clear_produce_debug() {
  produce_debug_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ComputeSpec::_internal_produce_debug() const {
  return produce_debug_;
}
inline bool ComputeSpec::produce_debug() const {
  // @@protoc_insertion_point(field_get:palantir.ComputeSpec.produce_debug)
  return _internal_produce_debug();
}
inline void ComputeSpec::_internal_set_produce_debug(bool value) {
  _has_bits_[0] |= 0x00000002u;
  produce_debug_ = value;
}
inline void ComputeSpec::set_produce_debug(bool value) {
  _internal_set_produce_debug(value);
  // @@protoc_insertion_point(field_set:palantir.ComputeSpec.produce_debug)
}

// -------------------------------------------------------------------

// StartReply

// .palantir.JobId job_id = 1;
inline bool StartReply::_internal_has_job_id() const {
  return this != internal_default_instance() && job_id_ != nullptr;
}
inline bool StartReply::has_job_id() const {
  return _internal_has_job_id();
}
inline void StartReply::clear_job_id() {
  if (GetArenaForAllocation() == nullptr && job_id_ != nullptr) {
    delete job_id_;
  }
  job_id_ = nullptr;
}
inline const ::palantir::JobId& StartReply::_internal_job_id() const {
  const ::palantir::JobId* p = job_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::palantir::JobId&>(
      ::palantir::_JobId_default_instance_);
}
inline const ::palantir::JobId& StartReply::job_id() const {
  // @@protoc_insertion_point(field_get:palantir.StartReply.job_id)
  return _internal_job_id();
}
inline void StartReply::unsafe_arena_set_allocated_job_id(
    ::palantir::JobId* job_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(job_id_);
  }
  job_id_ = job_id;
  if (job_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palantir.StartReply.job_id)
}
inline ::palantir::JobId* StartReply::release_job_id() {
  
  ::palantir::JobId* temp = job_id_;
  job_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::palantir::JobId* StartReply::unsafe_arena_release_job_id() {
  // @@protoc_insertion_point(field_release:palantir.StartReply.job_id)
  
  ::palantir::JobId* temp = job_id_;
  job_id_ = nullptr;
  return temp;
}
inline ::palantir::JobId* StartReply::_internal_mutable_job_id() {
  
  if (job_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::palantir::JobId>(GetArenaForAllocation());
    job_id_ = p;
  }
  return job_id_;
}
inline ::palantir::JobId* StartReply::mutable_job_id() {
  ::palantir::JobId* _msg = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:palantir.StartReply.job_id)
  return _msg;
}
inline void StartReply::set_allocated_job_id(::palantir::JobId* job_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete job_id_;
  }
  if (job_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::palantir::JobId>::GetOwningArena(job_id);
    if (message_arena != submessage_arena) {
      job_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, job_id, submessage_arena);
    }
    
  } else {
    
  }
  job_id_ = job_id;
  // @@protoc_insertion_point(field_set_allocated:palantir.StartReply.job_id)
}

// string status = 2;
inline void StartReply::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& StartReply::status() const {
  // @@protoc_insertion_point(field_get:palantir.StartReply.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartReply::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palantir.StartReply.status)
}
inline std::string* StartReply::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:palantir.StartReply.status)
  return _s;
}
inline const std::string& StartReply::_internal_status() const {
  return status_.Get();
}
inline void StartReply::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StartReply::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StartReply::release_status() {
  // @@protoc_insertion_point(field_release:palantir.StartReply.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StartReply::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (status_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palantir.StartReply.status)
}

// optional string error_message = 3;
inline bool StartReply::_internal_has_error_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StartReply::has_error_message() const {
  return _internal_has_error_message();
}
inline void StartReply::clear_error_message() {
  error_message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StartReply::error_message() const {
  // @@protoc_insertion_point(field_get:palantir.StartReply.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartReply::set_error_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palantir.StartReply.error_message)
}
inline std::string* StartReply::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:palantir.StartReply.error_message)
  return _s;
}
inline const std::string& StartReply::_internal_error_message() const {
  return error_message_.Get();
}
inline void StartReply::_internal_set_error_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StartReply::_internal_mutable_error_message() {
  _has_bits_[0] |= 0x00000001u;
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StartReply::release_error_message() {
  // @@protoc_insertion_point(field_release:palantir.StartReply.error_message)
  if (!_internal_has_error_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = error_message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StartReply::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palantir.StartReply.error_message)
}

// -------------------------------------------------------------------

// Progress

// .palantir.JobId job_id = 1;
inline bool Progress::_internal_has_job_id() const {
  return this != internal_default_instance() && job_id_ != nullptr;
}
inline bool Progress::has_job_id() const {
  return _internal_has_job_id();
}
inline void Progress::clear_job_id() {
  if (GetArenaForAllocation() == nullptr && job_id_ != nullptr) {
    delete job_id_;
  }
  job_id_ = nullptr;
}
inline const ::palantir::JobId& Progress::_internal_job_id() const {
  const ::palantir::JobId* p = job_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::palantir::JobId&>(
      ::palantir::_JobId_default_instance_);
}
inline const ::palantir::JobId& Progress::job_id() const {
  // @@protoc_insertion_point(field_get:palantir.Progress.job_id)
  return _internal_job_id();
}
inline void Progress::unsafe_arena_set_allocated_job_id(
    ::palantir::JobId* job_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(job_id_);
  }
  job_id_ = job_id;
  if (job_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palantir.Progress.job_id)
}
inline ::palantir::JobId* Progress::release_job_id() {
  
  ::palantir::JobId* temp = job_id_;
  job_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::palantir::JobId* Progress::unsafe_arena_release_job_id() {
  // @@protoc_insertion_point(field_release:palantir.Progress.job_id)
  
  ::palantir::JobId* temp = job_id_;
  job_id_ = nullptr;
  return temp;
}
inline ::palantir::JobId* Progress::_internal_mutable_job_id() {
  
  if (job_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::palantir::JobId>(GetArenaForAllocation());
    job_id_ = p;
  }
  return job_id_;
}
inline ::palantir::JobId* Progress::mutable_job_id() {
  ::palantir::JobId* _msg = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:palantir.Progress.job_id)
  return _msg;
}
inline void Progress::set_allocated_job_id(::palantir::JobId* job_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete job_id_;
  }
  if (job_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::palantir::JobId>::GetOwningArena(job_id);
    if (message_arena != submessage_arena) {
      job_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, job_id, submessage_arena);
    }
    
  } else {
    
  }
  job_id_ = job_id;
  // @@protoc_insertion_point(field_set_allocated:palantir.Progress.job_id)
}

// double progress_pct = 2;
inline void Progress::clear_progress_pct() {
  progress_pct_ = 0;
}
inline double Progress::_internal_progress_pct() const {
  return progress_pct_;
}
inline double Progress::progress_pct() const {
  // @@protoc_insertion_point(field_get:palantir.Progress.progress_pct)
  return _internal_progress_pct();
}
inline void Progress::_internal_set_progress_pct(double value) {
  
  progress_pct_ = value;
}
inline void Progress::set_progress_pct(double value) {
  _internal_set_progress_pct(value);
  // @@protoc_insertion_point(field_set:palantir.Progress.progress_pct)
}

// string status = 3;
inline void Progress::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& Progress::status() const {
  // @@protoc_insertion_point(field_get:palantir.Progress.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Progress::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palantir.Progress.status)
}
inline std::string* Progress::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:palantir.Progress.status)
  return _s;
}
inline const std::string& Progress::_internal_status() const {
  return status_.Get();
}
inline void Progress::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Progress::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Progress::release_status() {
  // @@protoc_insertion_point(field_release:palantir.Progress.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Progress::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (status_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palantir.Progress.status)
}

// optional string message = 4;
inline bool Progress::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Progress::has_message() const {
  return _internal_has_message();
}
inline void Progress::clear_message() {
  message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Progress::message() const {
  // @@protoc_insertion_point(field_get:palantir.Progress.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Progress::set_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palantir.Progress.message)
}
inline std::string* Progress::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:palantir.Progress.message)
  return _s;
}
inline const std::string& Progress::_internal_message() const {
  return message_.Get();
}
inline void Progress::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Progress::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Progress::release_message() {
  // @@protoc_insertion_point(field_release:palantir.Progress.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Progress::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palantir.Progress.message)
}

// -------------------------------------------------------------------

// ResultMeta

// .palantir.JobId job_id = 1;
inline bool ResultMeta::_internal_has_job_id() const {
  return this != internal_default_instance() && job_id_ != nullptr;
}
inline bool ResultMeta::has_job_id() const {
  return _internal_has_job_id();
}
inline void ResultMeta::clear_job_id() {
  if (GetArenaForAllocation() == nullptr && job_id_ != nullptr) {
    delete job_id_;
  }
  job_id_ = nullptr;
}
inline const ::palantir::JobId& ResultMeta::_internal_job_id() const {
  const ::palantir::JobId* p = job_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::palantir::JobId&>(
      ::palantir::_JobId_default_instance_);
}
inline const ::palantir::JobId& ResultMeta::job_id() const {
  // @@protoc_insertion_point(field_get:palantir.ResultMeta.job_id)
  return _internal_job_id();
}
inline void ResultMeta::unsafe_arena_set_allocated_job_id(
    ::palantir::JobId* job_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(job_id_);
  }
  job_id_ = job_id;
  if (job_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palantir.ResultMeta.job_id)
}
inline ::palantir::JobId* ResultMeta::release_job_id() {
  
  ::palantir::JobId* temp = job_id_;
  job_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::palantir::JobId* ResultMeta::unsafe_arena_release_job_id() {
  // @@protoc_insertion_point(field_release:palantir.ResultMeta.job_id)
  
  ::palantir::JobId* temp = job_id_;
  job_id_ = nullptr;
  return temp;
}
inline ::palantir::JobId* ResultMeta::_internal_mutable_job_id() {
  
  if (job_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::palantir::JobId>(GetArenaForAllocation());
    job_id_ = p;
  }
  return job_id_;
}
inline ::palantir::JobId* ResultMeta::mutable_job_id() {
  ::palantir::JobId* _msg = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:palantir.ResultMeta.job_id)
  return _msg;
}
inline void ResultMeta::set_allocated_job_id(::palantir::JobId* job_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete job_id_;
  }
  if (job_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::palantir::JobId>::GetOwningArena(job_id);
    if (message_arena != submessage_arena) {
      job_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, job_id, submessage_arena);
    }
    
  } else {
    
  }
  job_id_ = job_id;
  // @@protoc_insertion_point(field_set_allocated:palantir.ResultMeta.job_id)
}

// string status = 2;
inline void ResultMeta::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& ResultMeta::status() const {
  // @@protoc_insertion_point(field_get:palantir.ResultMeta.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResultMeta::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palantir.ResultMeta.status)
}
inline std::string* ResultMeta::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:palantir.ResultMeta.status)
  return _s;
}
inline const std::string& ResultMeta::_internal_status() const {
  return status_.Get();
}
inline void ResultMeta::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResultMeta::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResultMeta::release_status() {
  // @@protoc_insertion_point(field_release:palantir.ResultMeta.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResultMeta::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (status_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palantir.ResultMeta.status)
}

// string dtype = 3;
inline void ResultMeta::clear_dtype() {
  dtype_.ClearToEmpty();
}
inline const std::string& ResultMeta::dtype() const {
  // @@protoc_insertion_point(field_get:palantir.ResultMeta.dtype)
  return _internal_dtype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResultMeta::set_dtype(ArgT0&& arg0, ArgT... args) {
 
 dtype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palantir.ResultMeta.dtype)
}
inline std::string* ResultMeta::mutable_dtype() {
  std::string* _s = _internal_mutable_dtype();
  // @@protoc_insertion_point(field_mutable:palantir.ResultMeta.dtype)
  return _s;
}
inline const std::string& ResultMeta::_internal_dtype() const {
  return dtype_.Get();
}
inline void ResultMeta::_internal_set_dtype(const std::string& value) {
  
  dtype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResultMeta::_internal_mutable_dtype() {
  
  return dtype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResultMeta::release_dtype() {
  // @@protoc_insertion_point(field_release:palantir.ResultMeta.dtype)
  return dtype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResultMeta::set_allocated_dtype(std::string* dtype) {
  if (dtype != nullptr) {
    
  } else {
    
  }
  dtype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dtype,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dtype_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    dtype_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palantir.ResultMeta.dtype)
}

// repeated int32 shape = 4;
inline int ResultMeta::_internal_shape_size() const {
  return shape_.size();
}
inline int ResultMeta::shape_size() const {
  return _internal_shape_size();
}
inline void ResultMeta::clear_shape() {
  shape_.Clear();
}
inline int32_t ResultMeta::_internal_shape(int index) const {
  return shape_.Get(index);
}
inline int32_t ResultMeta::shape(int index) const {
  // @@protoc_insertion_point(field_get:palantir.ResultMeta.shape)
  return _internal_shape(index);
}
inline void ResultMeta::set_shape(int index, int32_t value) {
  shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:palantir.ResultMeta.shape)
}
inline void ResultMeta::_internal_add_shape(int32_t value) {
  shape_.Add(value);
}
inline void ResultMeta::add_shape(int32_t value) {
  _internal_add_shape(value);
  // @@protoc_insertion_point(field_add:palantir.ResultMeta.shape)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ResultMeta::_internal_shape() const {
  return shape_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ResultMeta::shape() const {
  // @@protoc_insertion_point(field_list:palantir.ResultMeta.shape)
  return _internal_shape();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ResultMeta::_internal_mutable_shape() {
  return &shape_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ResultMeta::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:palantir.ResultMeta.shape)
  return _internal_mutable_shape();
}

// int64 compute_elapsed_ms = 5;
inline void ResultMeta::clear_compute_elapsed_ms() {
  compute_elapsed_ms_ = int64_t{0};
}
inline int64_t ResultMeta::_internal_compute_elapsed_ms() const {
  return compute_elapsed_ms_;
}
inline int64_t ResultMeta::compute_elapsed_ms() const {
  // @@protoc_insertion_point(field_get:palantir.ResultMeta.compute_elapsed_ms)
  return _internal_compute_elapsed_ms();
}
inline void ResultMeta::_internal_set_compute_elapsed_ms(int64_t value) {
  
  compute_elapsed_ms_ = value;
}
inline void ResultMeta::set_compute_elapsed_ms(int64_t value) {
  _internal_set_compute_elapsed_ms(value);
  // @@protoc_insertion_point(field_set:palantir.ResultMeta.compute_elapsed_ms)
}

// int64 bytes_total = 6;
inline void ResultMeta::clear_bytes_total() {
  bytes_total_ = int64_t{0};
}
inline int64_t ResultMeta::_internal_bytes_total() const {
  return bytes_total_;
}
inline int64_t ResultMeta::bytes_total() const {
  // @@protoc_insertion_point(field_get:palantir.ResultMeta.bytes_total)
  return _internal_bytes_total();
}
inline void ResultMeta::_internal_set_bytes_total(int64_t value) {
  
  bytes_total_ = value;
}
inline void ResultMeta::set_bytes_total(int64_t value) {
  _internal_set_bytes_total(value);
  // @@protoc_insertion_point(field_set:palantir.ResultMeta.bytes_total)
}

// repeated string labels = 7;
inline int ResultMeta::_internal_labels_size() const {
  return labels_.size();
}
inline int ResultMeta::labels_size() const {
  return _internal_labels_size();
}
inline void ResultMeta::clear_labels() {
  labels_.Clear();
}
inline std::string* ResultMeta::add_labels() {
  std::string* _s = _internal_add_labels();
  // @@protoc_insertion_point(field_add_mutable:palantir.ResultMeta.labels)
  return _s;
}
inline const std::string& ResultMeta::_internal_labels(int index) const {
  return labels_.Get(index);
}
inline const std::string& ResultMeta::labels(int index) const {
  // @@protoc_insertion_point(field_get:palantir.ResultMeta.labels)
  return _internal_labels(index);
}
inline std::string* ResultMeta::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:palantir.ResultMeta.labels)
  return labels_.Mutable(index);
}
inline void ResultMeta::set_labels(int index, const std::string& value) {
  labels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:palantir.ResultMeta.labels)
}
inline void ResultMeta::set_labels(int index, std::string&& value) {
  labels_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:palantir.ResultMeta.labels)
}
inline void ResultMeta::set_labels(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  labels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:palantir.ResultMeta.labels)
}
inline void ResultMeta::set_labels(int index, const char* value, size_t size) {
  labels_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palantir.ResultMeta.labels)
}
inline std::string* ResultMeta::_internal_add_labels() {
  return labels_.Add();
}
inline void ResultMeta::add_labels(const std::string& value) {
  labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:palantir.ResultMeta.labels)
}
inline void ResultMeta::add_labels(std::string&& value) {
  labels_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:palantir.ResultMeta.labels)
}
inline void ResultMeta::add_labels(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:palantir.ResultMeta.labels)
}
inline void ResultMeta::add_labels(const char* value, size_t size) {
  labels_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:palantir.ResultMeta.labels)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ResultMeta::labels() const {
  // @@protoc_insertion_point(field_list:palantir.ResultMeta.labels)
  return labels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ResultMeta::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:palantir.ResultMeta.labels)
  return &labels_;
}

// optional string error_message = 8;
inline bool ResultMeta::_internal_has_error_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResultMeta::has_error_message() const {
  return _internal_has_error_message();
}
inline void ResultMeta::clear_error_message() {
  error_message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResultMeta::error_message() const {
  // @@protoc_insertion_point(field_get:palantir.ResultMeta.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResultMeta::set_error_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palantir.ResultMeta.error_message)
}
inline std::string* ResultMeta::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:palantir.ResultMeta.error_message)
  return _s;
}
inline const std::string& ResultMeta::_internal_error_message() const {
  return error_message_.Get();
}
inline void ResultMeta::_internal_set_error_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResultMeta::_internal_mutable_error_message() {
  _has_bits_[0] |= 0x00000001u;
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResultMeta::release_error_message() {
  // @@protoc_insertion_point(field_release:palantir.ResultMeta.error_message)
  if (!_internal_has_error_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = error_message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResultMeta::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palantir.ResultMeta.error_message)
}

// -------------------------------------------------------------------

// DataChunk

// .palantir.JobId job_id = 1;
inline bool DataChunk::_internal_has_job_id() const {
  return this != internal_default_instance() && job_id_ != nullptr;
}
inline bool DataChunk::has_job_id() const {
  return _internal_has_job_id();
}
inline void DataChunk::clear_job_id() {
  if (GetArenaForAllocation() == nullptr && job_id_ != nullptr) {
    delete job_id_;
  }
  job_id_ = nullptr;
}
inline const ::palantir::JobId& DataChunk::_internal_job_id() const {
  const ::palantir::JobId* p = job_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::palantir::JobId&>(
      ::palantir::_JobId_default_instance_);
}
inline const ::palantir::JobId& DataChunk::job_id() const {
  // @@protoc_insertion_point(field_get:palantir.DataChunk.job_id)
  return _internal_job_id();
}
inline void DataChunk::unsafe_arena_set_allocated_job_id(
    ::palantir::JobId* job_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(job_id_);
  }
  job_id_ = job_id;
  if (job_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palantir.DataChunk.job_id)
}
inline ::palantir::JobId* DataChunk::release_job_id() {
  
  ::palantir::JobId* temp = job_id_;
  job_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::palantir::JobId* DataChunk::unsafe_arena_release_job_id() {
  // @@protoc_insertion_point(field_release:palantir.DataChunk.job_id)
  
  ::palantir::JobId* temp = job_id_;
  job_id_ = nullptr;
  return temp;
}
inline ::palantir::JobId* DataChunk::_internal_mutable_job_id() {
  
  if (job_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::palantir::JobId>(GetArenaForAllocation());
    job_id_ = p;
  }
  return job_id_;
}
inline ::palantir::JobId* DataChunk::mutable_job_id() {
  ::palantir::JobId* _msg = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:palantir.DataChunk.job_id)
  return _msg;
}
inline void DataChunk::set_allocated_job_id(::palantir::JobId* job_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete job_id_;
  }
  if (job_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::palantir::JobId>::GetOwningArena(job_id);
    if (message_arena != submessage_arena) {
      job_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, job_id, submessage_arena);
    }
    
  } else {
    
  }
  job_id_ = job_id;
  // @@protoc_insertion_point(field_set_allocated:palantir.DataChunk.job_id)
}

// int32 chunk_index = 2;
inline void DataChunk::clear_chunk_index() {
  chunk_index_ = 0;
}
inline int32_t DataChunk::_internal_chunk_index() const {
  return chunk_index_;
}
inline int32_t DataChunk::chunk_index() const {
  // @@protoc_insertion_point(field_get:palantir.DataChunk.chunk_index)
  return _internal_chunk_index();
}
inline void DataChunk::_internal_set_chunk_index(int32_t value) {
  
  chunk_index_ = value;
}
inline void DataChunk::set_chunk_index(int32_t value) {
  _internal_set_chunk_index(value);
  // @@protoc_insertion_point(field_set:palantir.DataChunk.chunk_index)
}

// int32 total_chunks = 3;
inline void DataChunk::clear_total_chunks() {
  total_chunks_ = 0;
}
inline int32_t DataChunk::_internal_total_chunks() const {
  return total_chunks_;
}
inline int32_t DataChunk::total_chunks() const {
  // @@protoc_insertion_point(field_get:palantir.DataChunk.total_chunks)
  return _internal_total_chunks();
}
inline void DataChunk::_internal_set_total_chunks(int32_t value) {
  
  total_chunks_ = value;
}
inline void DataChunk::set_total_chunks(int32_t value) {
  _internal_set_total_chunks(value);
  // @@protoc_insertion_point(field_set:palantir.DataChunk.total_chunks)
}

// bytes data = 4;
inline void DataChunk::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& DataChunk::data() const {
  // @@protoc_insertion_point(field_get:palantir.DataChunk.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataChunk::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palantir.DataChunk.data)
}
inline std::string* DataChunk::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:palantir.DataChunk.data)
  return _s;
}
inline const std::string& DataChunk::_internal_data() const {
  return data_.Get();
}
inline void DataChunk::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DataChunk::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DataChunk::release_data() {
  // @@protoc_insertion_point(field_release:palantir.DataChunk.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DataChunk::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palantir.DataChunk.data)
}

// -------------------------------------------------------------------

// Cancel

// .palantir.JobId job_id = 1;
inline bool Cancel::_internal_has_job_id() const {
  return this != internal_default_instance() && job_id_ != nullptr;
}
inline bool Cancel::has_job_id() const {
  return _internal_has_job_id();
}
inline void Cancel::clear_job_id() {
  if (GetArenaForAllocation() == nullptr && job_id_ != nullptr) {
    delete job_id_;
  }
  job_id_ = nullptr;
}
inline const ::palantir::JobId& Cancel::_internal_job_id() const {
  const ::palantir::JobId* p = job_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::palantir::JobId&>(
      ::palantir::_JobId_default_instance_);
}
inline const ::palantir::JobId& Cancel::job_id() const {
  // @@protoc_insertion_point(field_get:palantir.Cancel.job_id)
  return _internal_job_id();
}
inline void Cancel::unsafe_arena_set_allocated_job_id(
    ::palantir::JobId* job_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(job_id_);
  }
  job_id_ = job_id;
  if (job_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palantir.Cancel.job_id)
}
inline ::palantir::JobId* Cancel::release_job_id() {
  
  ::palantir::JobId* temp = job_id_;
  job_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::palantir::JobId* Cancel::unsafe_arena_release_job_id() {
  // @@protoc_insertion_point(field_release:palantir.Cancel.job_id)
  
  ::palantir::JobId* temp = job_id_;
  job_id_ = nullptr;
  return temp;
}
inline ::palantir::JobId* Cancel::_internal_mutable_job_id() {
  
  if (job_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::palantir::JobId>(GetArenaForAllocation());
    job_id_ = p;
  }
  return job_id_;
}
inline ::palantir::JobId* Cancel::mutable_job_id() {
  ::palantir::JobId* _msg = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:palantir.Cancel.job_id)
  return _msg;
}
inline void Cancel::set_allocated_job_id(::palantir::JobId* job_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete job_id_;
  }
  if (job_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::palantir::JobId>::GetOwningArena(job_id);
    if (message_arena != submessage_arena) {
      job_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, job_id, submessage_arena);
    }
    
  } else {
    
  }
  job_id_ = job_id;
  // @@protoc_insertion_point(field_set_allocated:palantir.Cancel.job_id)
}

// -------------------------------------------------------------------

// StartJob

// .palantir.JobId job_id = 1;
inline bool StartJob::_internal_has_job_id() const {
  return this != internal_default_instance() && job_id_ != nullptr;
}
inline bool StartJob::has_job_id() const {
  return _internal_has_job_id();
}
inline void StartJob::clear_job_id() {
  if (GetArenaForAllocation() == nullptr && job_id_ != nullptr) {
    delete job_id_;
  }
  job_id_ = nullptr;
}
inline const ::palantir::JobId& StartJob::_internal_job_id() const {
  const ::palantir::JobId* p = job_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::palantir::JobId&>(
      ::palantir::_JobId_default_instance_);
}
inline const ::palantir::JobId& StartJob::job_id() const {
  // @@protoc_insertion_point(field_get:palantir.StartJob.job_id)
  return _internal_job_id();
}
inline void StartJob::unsafe_arena_set_allocated_job_id(
    ::palantir::JobId* job_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(job_id_);
  }
  job_id_ = job_id;
  if (job_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palantir.StartJob.job_id)
}
inline ::palantir::JobId* StartJob::release_job_id() {
  
  ::palantir::JobId* temp = job_id_;
  job_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::palantir::JobId* StartJob::unsafe_arena_release_job_id() {
  // @@protoc_insertion_point(field_release:palantir.StartJob.job_id)
  
  ::palantir::JobId* temp = job_id_;
  job_id_ = nullptr;
  return temp;
}
inline ::palantir::JobId* StartJob::_internal_mutable_job_id() {
  
  if (job_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::palantir::JobId>(GetArenaForAllocation());
    job_id_ = p;
  }
  return job_id_;
}
inline ::palantir::JobId* StartJob::mutable_job_id() {
  ::palantir::JobId* _msg = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:palantir.StartJob.job_id)
  return _msg;
}
inline void StartJob::set_allocated_job_id(::palantir::JobId* job_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete job_id_;
  }
  if (job_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::palantir::JobId>::GetOwningArena(job_id);
    if (message_arena != submessage_arena) {
      job_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, job_id, submessage_arena);
    }
    
  } else {
    
  }
  job_id_ = job_id;
  // @@protoc_insertion_point(field_set_allocated:palantir.StartJob.job_id)
}

// .palantir.ComputeSpec spec = 2;
inline bool StartJob::_internal_has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline bool StartJob::has_spec() const {
  return _internal_has_spec();
}
inline void StartJob::clear_spec() {
  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::palantir::ComputeSpec& StartJob::_internal_spec() const {
  const ::palantir::ComputeSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::palantir::ComputeSpec&>(
      ::palantir::_ComputeSpec_default_instance_);
}
inline const ::palantir::ComputeSpec& StartJob::spec() const {
  // @@protoc_insertion_point(field_get:palantir.StartJob.spec)
  return _internal_spec();
}
inline void StartJob::unsafe_arena_set_allocated_spec(
    ::palantir::ComputeSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palantir.StartJob.spec)
}
inline ::palantir::ComputeSpec* StartJob::release_spec() {
  
  ::palantir::ComputeSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::palantir::ComputeSpec* StartJob::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:palantir.StartJob.spec)
  
  ::palantir::ComputeSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::palantir::ComputeSpec* StartJob::_internal_mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::palantir::ComputeSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::palantir::ComputeSpec* StartJob::mutable_spec() {
  ::palantir::ComputeSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:palantir.StartJob.spec)
  return _msg;
}
inline void StartJob::set_allocated_spec(::palantir::ComputeSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::palantir::ComputeSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:palantir.StartJob.spec)
}

// -------------------------------------------------------------------

// CapabilitiesRequest

// -------------------------------------------------------------------

// Capabilities

// int32 max_concurrency = 1;
inline void Capabilities::clear_max_concurrency() {
  max_concurrency_ = 0;
}
inline int32_t Capabilities::_internal_max_concurrency() const {
  return max_concurrency_;
}
inline int32_t Capabilities::max_concurrency() const {
  // @@protoc_insertion_point(field_get:palantir.Capabilities.max_concurrency)
  return _internal_max_concurrency();
}
inline void Capabilities::_internal_set_max_concurrency(int32_t value) {
  
  max_concurrency_ = value;
}
inline void Capabilities::set_max_concurrency(int32_t value) {
  _internal_set_max_concurrency(value);
  // @@protoc_insertion_point(field_set:palantir.Capabilities.max_concurrency)
}

// repeated string supported_features = 2;
inline int Capabilities::_internal_supported_features_size() const {
  return supported_features_.size();
}
inline int Capabilities::supported_features_size() const {
  return _internal_supported_features_size();
}
inline void Capabilities::clear_supported_features() {
  supported_features_.Clear();
}
inline std::string* Capabilities::add_supported_features() {
  std::string* _s = _internal_add_supported_features();
  // @@protoc_insertion_point(field_add_mutable:palantir.Capabilities.supported_features)
  return _s;
}
inline const std::string& Capabilities::_internal_supported_features(int index) const {
  return supported_features_.Get(index);
}
inline const std::string& Capabilities::supported_features(int index) const {
  // @@protoc_insertion_point(field_get:palantir.Capabilities.supported_features)
  return _internal_supported_features(index);
}
inline std::string* Capabilities::mutable_supported_features(int index) {
  // @@protoc_insertion_point(field_mutable:palantir.Capabilities.supported_features)
  return supported_features_.Mutable(index);
}
inline void Capabilities::set_supported_features(int index, const std::string& value) {
  supported_features_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:palantir.Capabilities.supported_features)
}
inline void Capabilities::set_supported_features(int index, std::string&& value) {
  supported_features_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:palantir.Capabilities.supported_features)
}
inline void Capabilities::set_supported_features(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  supported_features_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:palantir.Capabilities.supported_features)
}
inline void Capabilities::set_supported_features(int index, const char* value, size_t size) {
  supported_features_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palantir.Capabilities.supported_features)
}
inline std::string* Capabilities::_internal_add_supported_features() {
  return supported_features_.Add();
}
inline void Capabilities::add_supported_features(const std::string& value) {
  supported_features_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:palantir.Capabilities.supported_features)
}
inline void Capabilities::add_supported_features(std::string&& value) {
  supported_features_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:palantir.Capabilities.supported_features)
}
inline void Capabilities::add_supported_features(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  supported_features_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:palantir.Capabilities.supported_features)
}
inline void Capabilities::add_supported_features(const char* value, size_t size) {
  supported_features_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:palantir.Capabilities.supported_features)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Capabilities::supported_features() const {
  // @@protoc_insertion_point(field_list:palantir.Capabilities.supported_features)
  return supported_features_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Capabilities::mutable_supported_features() {
  // @@protoc_insertion_point(field_mutable_list:palantir.Capabilities.supported_features)
  return &supported_features_;
}

// string protocol_version = 3;
inline void Capabilities::clear_protocol_version() {
  protocol_version_.ClearToEmpty();
}
inline const std::string& Capabilities::protocol_version() const {
  // @@protoc_insertion_point(field_get:palantir.Capabilities.protocol_version)
  return _internal_protocol_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Capabilities::set_protocol_version(ArgT0&& arg0, ArgT... args) {
 
 protocol_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palantir.Capabilities.protocol_version)
}
inline std::string* Capabilities::mutable_protocol_version() {
  std::string* _s = _internal_mutable_protocol_version();
  // @@protoc_insertion_point(field_mutable:palantir.Capabilities.protocol_version)
  return _s;
}
inline const std::string& Capabilities::_internal_protocol_version() const {
  return protocol_version_.Get();
}
inline void Capabilities::_internal_set_protocol_version(const std::string& value) {
  
  protocol_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Capabilities::_internal_mutable_protocol_version() {
  
  return protocol_version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Capabilities::release_protocol_version() {
  // @@protoc_insertion_point(field_release:palantir.Capabilities.protocol_version)
  return protocol_version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Capabilities::set_allocated_protocol_version(std::string* protocol_version) {
  if (protocol_version != nullptr) {
    
  } else {
    
  }
  protocol_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), protocol_version,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (protocol_version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    protocol_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palantir.Capabilities.protocol_version)
}

// -------------------------------------------------------------------

// Pong

// int64 timestamp_ms = 1;
inline void Pong::clear_timestamp_ms() {
  timestamp_ms_ = int64_t{0};
}
inline int64_t Pong::_internal_timestamp_ms() const {
  return timestamp_ms_;
}
inline int64_t Pong::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:palantir.Pong.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void Pong::_internal_set_timestamp_ms(int64_t value) {
  
  timestamp_ms_ = value;
}
inline void Pong::set_timestamp_ms(int64_t value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:palantir.Pong.timestamp_ms)
}

// -------------------------------------------------------------------

// XYSineSpec

// double amplitude = 1;
inline void XYSineSpec::clear_amplitude() {
  amplitude_ = 0;
}
inline double XYSineSpec::_internal_amplitude() const {
  return amplitude_;
}
inline double XYSineSpec::amplitude() const {
  // @@protoc_insertion_point(field_get:palantir.XYSineSpec.amplitude)
  return _internal_amplitude();
}
inline void XYSineSpec::_internal_set_amplitude(double value) {
  
  amplitude_ = value;
}
inline void XYSineSpec::set_amplitude(double value) {
  _internal_set_amplitude(value);
  // @@protoc_insertion_point(field_set:palantir.XYSineSpec.amplitude)
}

// double frequency = 2;
inline void XYSineSpec::clear_frequency() {
  frequency_ = 0;
}
inline double XYSineSpec::_internal_frequency() const {
  return frequency_;
}
inline double XYSineSpec::frequency() const {
  // @@protoc_insertion_point(field_get:palantir.XYSineSpec.frequency)
  return _internal_frequency();
}
inline void XYSineSpec::_internal_set_frequency(double value) {
  
  frequency_ = value;
}
inline void XYSineSpec::set_frequency(double value) {
  _internal_set_frequency(value);
  // @@protoc_insertion_point(field_set:palantir.XYSineSpec.frequency)
}

// double phase = 3;
inline void XYSineSpec::clear_phase() {
  phase_ = 0;
}
inline double XYSineSpec::_internal_phase() const {
  return phase_;
}
inline double XYSineSpec::phase() const {
  // @@protoc_insertion_point(field_get:palantir.XYSineSpec.phase)
  return _internal_phase();
}
inline void XYSineSpec::_internal_set_phase(double value) {
  
  phase_ = value;
}
inline void XYSineSpec::set_phase(double value) {
  _internal_set_phase(value);
  // @@protoc_insertion_point(field_set:palantir.XYSineSpec.phase)
}

// int32 cycles = 4;
inline void XYSineSpec::clear_cycles() {
  cycles_ = 0;
}
inline int32_t XYSineSpec::_internal_cycles() const {
  return cycles_;
}
inline int32_t XYSineSpec::cycles() const {
  // @@protoc_insertion_point(field_get:palantir.XYSineSpec.cycles)
  return _internal_cycles();
}
inline void XYSineSpec::_internal_set_cycles(int32_t value) {
  
  cycles_ = value;
}
inline void XYSineSpec::set_cycles(int32_t value) {
  _internal_set_cycles(value);
  // @@protoc_insertion_point(field_set:palantir.XYSineSpec.cycles)
}

// int32 n_samples = 5;
inline void XYSineSpec::clear_n_samples() {
  n_samples_ = 0;
}
inline int32_t XYSineSpec::_internal_n_samples() const {
  return n_samples_;
}
inline int32_t XYSineSpec::n_samples() const {
  // @@protoc_insertion_point(field_get:palantir.XYSineSpec.n_samples)
  return _internal_n_samples();
}
inline void XYSineSpec::_internal_set_n_samples(int32_t value) {
  
  n_samples_ = value;
}
inline void XYSineSpec::set_n_samples(int32_t value) {
  _internal_set_n_samples(value);
  // @@protoc_insertion_point(field_set:palantir.XYSineSpec.n_samples)
}

// -------------------------------------------------------------------

// XYSineResult

// repeated double x_values = 1;
inline int XYSineResult::_internal_x_values_size() const {
  return x_values_.size();
}
inline int XYSineResult::x_values_size() const {
  return _internal_x_values_size();
}
inline void XYSineResult::clear_x_values() {
  x_values_.Clear();
}
inline double XYSineResult::_internal_x_values(int index) const {
  return x_values_.Get(index);
}
inline double XYSineResult::x_values(int index) const {
  // @@protoc_insertion_point(field_get:palantir.XYSineResult.x_values)
  return _internal_x_values(index);
}
inline void XYSineResult::set_x_values(int index, double value) {
  x_values_.Set(index, value);
  // @@protoc_insertion_point(field_set:palantir.XYSineResult.x_values)
}
inline void XYSineResult::_internal_add_x_values(double value) {
  x_values_.Add(value);
}
inline void XYSineResult::add_x_values(double value) {
  _internal_add_x_values(value);
  // @@protoc_insertion_point(field_add:palantir.XYSineResult.x_values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
XYSineResult::_internal_x_values() const {
  return x_values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
XYSineResult::x_values() const {
  // @@protoc_insertion_point(field_list:palantir.XYSineResult.x_values)
  return _internal_x_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
XYSineResult::_internal_mutable_x_values() {
  return &x_values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
XYSineResult::mutable_x_values() {
  // @@protoc_insertion_point(field_mutable_list:palantir.XYSineResult.x_values)
  return _internal_mutable_x_values();
}

// repeated double y_values = 2;
inline int XYSineResult::_internal_y_values_size() const {
  return y_values_.size();
}
inline int XYSineResult::y_values_size() const {
  return _internal_y_values_size();
}
inline void XYSineResult::clear_y_values() {
  y_values_.Clear();
}
inline double XYSineResult::_internal_y_values(int index) const {
  return y_values_.Get(index);
}
inline double XYSineResult::y_values(int index) const {
  // @@protoc_insertion_point(field_get:palantir.XYSineResult.y_values)
  return _internal_y_values(index);
}
inline void XYSineResult::set_y_values(int index, double value) {
  y_values_.Set(index, value);
  // @@protoc_insertion_point(field_set:palantir.XYSineResult.y_values)
}
inline void XYSineResult::_internal_add_y_values(double value) {
  y_values_.Add(value);
}
inline void XYSineResult::add_y_values(double value) {
  _internal_add_y_values(value);
  // @@protoc_insertion_point(field_add:palantir.XYSineResult.y_values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
XYSineResult::_internal_y_values() const {
  return y_values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
XYSineResult::y_values() const {
  // @@protoc_insertion_point(field_list:palantir.XYSineResult.y_values)
  return _internal_y_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
XYSineResult::_internal_mutable_y_values() {
  return &y_values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
XYSineResult::mutable_y_values() {
  // @@protoc_insertion_point(field_mutable_list:palantir.XYSineResult.y_values)
  return _internal_mutable_y_values();
}

// int32 series_points = 3;
inline void XYSineResult::clear_series_points() {
  series_points_ = 0;
}
inline int32_t XYSineResult::_internal_series_points() const {
  return series_points_;
}
inline int32_t XYSineResult::series_points() const {
  // @@protoc_insertion_point(field_get:palantir.XYSineResult.series_points)
  return _internal_series_points();
}
inline void XYSineResult::_internal_set_series_points(int32_t value) {
  
  series_points_ = value;
}
inline void XYSineResult::set_series_points(int32_t value) {
  _internal_set_series_points(value);
  // @@protoc_insertion_point(field_set:palantir.XYSineResult.series_points)
}

// int32 series_points_effective = 4;
inline void XYSineResult::clear_series_points_effective() {
  series_points_effective_ = 0;
}
inline int32_t XYSineResult::_internal_series_points_effective() const {
  return series_points_effective_;
}
inline int32_t XYSineResult::series_points_effective() const {
  // @@protoc_insertion_point(field_get:palantir.XYSineResult.series_points_effective)
  return _internal_series_points_effective();
}
inline void XYSineResult::_internal_set_series_points_effective(int32_t value) {
  
  series_points_effective_ = value;
}
inline void XYSineResult::set_series_points_effective(int32_t value) {
  _internal_set_series_points_effective(value);
  // @@protoc_insertion_point(field_set:palantir.XYSineResult.series_points_effective)
}

// bool downsampling_enabled = 5;
inline void XYSineResult::clear_downsampling_enabled() {
  downsampling_enabled_ = false;
}
inline bool XYSineResult::_internal_downsampling_enabled() const {
  return downsampling_enabled_;
}
inline bool XYSineResult::downsampling_enabled() const {
  // @@protoc_insertion_point(field_get:palantir.XYSineResult.downsampling_enabled)
  return _internal_downsampling_enabled();
}
inline void XYSineResult::_internal_set_downsampling_enabled(bool value) {
  
  downsampling_enabled_ = value;
}
inline void XYSineResult::set_downsampling_enabled(bool value) {
  _internal_set_downsampling_enabled(value);
  // @@protoc_insertion_point(field_set:palantir.XYSineResult.downsampling_enabled)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace palantir

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_palantir_2eproto
