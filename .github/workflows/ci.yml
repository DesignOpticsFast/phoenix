name: CI

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
    branches: [ main ]        # ensure main is included
  push:
    branches: [ main ]        # always build on main pushes
  workflow_dispatch:
    inputs:
      pr:
        description: 'PR number (optional)'
        required: false
  schedule:
    - cron: "0 9 * * 1"       # every Monday 09:00 UTC - weekly self-audit

permissions:
  contents: read
  pull-requests: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  pre-build-checks:
    name: Pre-build resource checks
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
      
      - name: Validate QRC entries
        run: |
          set -e
          QRC_FILE="src/ui/icons/phoenix_icons.qrc"
          if [ ! -f "$QRC_FILE" ]; then
            echo "❌ QRC file not found: $QRC_FILE"
            exit 1
          fi
          
          # Extract file paths from QRC using sed to parse XML
          QRC_DIR="$(dirname "$QRC_FILE")"
          while IFS= read -r line; do
            # Extract path between > and </file>
            file_path=$(echo "$line" | sed -n 's/.*>\(.*\)<\/file>/\1/p')
            if [ -n "$file_path" ]; then
              # Resolve relative path from qrc location
              full_path="$QRC_DIR/$file_path"
              if [ ! -f "$full_path" ]; then
                echo "❌ QRC entry points to missing file: $file_path (resolved: $full_path)"
                exit 1
              fi
            fi
          done < <(grep '<file' "$QRC_FILE")
          
          echo "✅ All QRC entries validated"
      
      - name: Check SVG currentColor usage
        run: |
          set -e
          # Check non-branding SVGs for hardcoded colors
          # Branding SVGs (phoenix-icon.svg) are exempt
          SVG_DIR="assets/icons/fontawesome-pro/svgs"
          if [ ! -d "$SVG_DIR" ]; then
            echo "⚠️  SVG directory not found, skipping check"
            exit 0
          fi
          
          # Find SVGs with hardcoded fill or stroke (excluding branding)
          VIOLATIONS=$(find "$SVG_DIR" -name "*.svg" ! -name "*phoenix*" -exec grep -l 'fill="#[^c]' {} \; 2>/dev/null || true)
          if [ -n "$VIOLATIONS" ]; then
            echo "❌ Found SVGs with hardcoded fill colors (should use fill=\"currentColor\"):"
            echo "$VIOLATIONS"
            exit 1
          fi
          
          VIOLATIONS=$(find "$SVG_DIR" -name "*.svg" ! -name "*phoenix*" -exec grep -l 'stroke="#[^c]' {} \; 2>/dev/null || true)
          if [ -n "$VIOLATIONS" ]; then
            echo "❌ Found SVGs with hardcoded stroke colors (should use stroke=\"currentColor\"):"
            echo "$VIOLATIONS"
            exit 1
          fi
          
          echo "✅ SVG color check passed"

  changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      docs_only: ${{ steps.classify.outputs.docs_only }}
      code_changed: ${{ steps.classify.outputs.code_changed }}
      ci_only: ${{ steps.classify.outputs.ci_only }}
    steps:
      - name: Checkout (full history)
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          # For PRs, point at the head ref explicitly to avoid shallow/detached surprises
          ref: ${{ github.event.pull_request.head.sha || github.sha }}

      # Guard: no conflict markers in workflows
      - name: Guard - no conflict markers in workflows
        run: |
          if grep -R -nE '^<<<<<<<|^>>>>>>>' .github/workflows ; then
            echo "❌ Conflict markers found in workflow files"; exit 1;
          fi

      # Lint workflows (temporarily disabled to get CI working)
      # - name: Lint workflows
      #   uses: ibiqlik/action-yamllint@v3
      #   with:
      #     file_or_dir: .github/workflows
      #     config_file: .yamllint.yml

      - name: Detect changed paths
        id: filter
        uses: dorny/paths-filter@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          filters: |
            docs:
              - 'docs/**'
              - '**/*.md'
              - 'assets/docs/**'
              - 'docs-assets/**'
            code:
              - 'src/**'
              - 'cmake/**'
              - 'CMakeLists.txt'
              - '**/*.{cpp,cxx,c,h,hpp,ui,qrc,qml,rc,ico,icns}'
            ci:
              - '.github/workflows/**'

      # OPTIONAL but hugely helpful: print what matched
      - name: Debug - show classification
        shell: bash
        run: |
          echo "docs=${{ steps.filter.outputs.docs }}"
          echo "code=${{ steps.filter.outputs.code }}"
          echo "ci=${{ steps.filter.outputs.ci }}"
          echo "docs_files:"
          echo "${{ steps.filter.outputs.docs_files }}"
          echo "code_files:"
          echo "${{ steps.filter.outputs.code_files }}"
          echo "ci_files:"
          echo "${{ steps.filter.outputs.ci_files }}"

      - name: Classify (docs/code/ci)
        id: classify
        shell: bash
        run: |
          set -euo pipefail
          docs="${{ steps.filter.outputs.docs }}"
          code="${{ steps.filter.outputs.code }}"
          ci="${{ steps.filter.outputs.ci }}"

          # NEW: handle "no matched files" (avoid kicking off a build)
          if [[ "$docs" == "false" && "$code" == "false" && "$ci" == "false" ]]; then
            echo "docs_only=false"     >>"$GITHUB_OUTPUT"
            echo "code_changed=false"  >>"$GITHUB_OUTPUT"
            echo "ci_only=false"       >>"$GITHUB_OUTPUT"
            exit 0
          fi

          if [[ "$docs" == "true" && "$code" == "false" && "$ci" == "false" ]]; then
            echo "docs_only=true"      >>"$GITHUB_OUTPUT"
            echo "code_changed=false"  >>"$GITHUB_OUTPUT"
            echo "ci_only=false"       >>"$GITHUB_OUTPUT"
          elif [[ "$ci" == "true" && "$code" == "false" && "$docs" == "false" ]]; then
            echo "docs_only=false"     >>"$GITHUB_OUTPUT"
            echo "code_changed=false"  >>"$GITHUB_OUTPUT"
            echo "ci_only=true"        >>"$GITHUB_OUTPUT"
          else
            echo "docs_only=false"     >>"$GITHUB_OUTPUT"
            echo "code_changed=true"   >>"$GITHUB_OUTPUT"
            echo "ci_only=false"       >>"$GITHUB_OUTPUT"
          fi

  docs:
    needs: changes
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && needs.changes.outputs.docs_only == 'true'
    steps:
      - uses: actions/checkout@v5
      - uses: DavidAnson/markdownlint-cli2-action@v20
        with:
          globs: |
            **/*.md
            !.github/**
            !.underlord/**
            !docs/palantir/**
            !assets/**
            !ci-audit-package/**
            !CHANGELOG.md
      - name: link check
        uses: lycheeverse/lychee-action@v2   # pin to v1 while stabilizing
        with:
          args: >
            --no-progress --include-fragments
            --max-concurrency 4 --max-redirects 5
            --retry-wait-time 2 --retry-count 1 --timeout 20
            --accept 200,206 .
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - uses: codespell-project/actions-codespell@v2
        with:
          path: docs .
          skip: .git,build

  build:
    name: Build (Qt on dev-01)
    needs: changes
    timeout-minutes: 30
    if: >
      (github.event_name == 'push') ||
      (github.event_name == 'pull_request' &&
       github.event.pull_request.head.repo.full_name == github.repository &&
       needs.changes.outputs.code_changed == 'true')
    runs-on: [self-hosted, Linux, X64, dev-01, qt6]
    concurrency:
      group: dev01-build
      cancel-in-progress: false
    env:
      QT_VERSION: 6.10.0
      QT_PATH: /opt/Qt/6.10.0/gcc_64
      CMAKE_PREFIX_PATH: /opt/Qt/6.10.0/gcc_64
      QTFRAMEWORK_BYPASS_LICENSE_CHECK: "1"
    steps:
      - uses: actions/checkout@v5
      
      - name: Verify dev-01 labels & env
        shell: bash
        run: |
          echo "labels = ${{ toJson(runner.labels) }}"
          echo "QT_VERSION=${QT_VERSION:-<unset>}"
          echo "CMAKE_PREFIX_PATH=${CMAKE_PREFIX_PATH:-<unset>}"
          echo "QTFRAMEWORK_BYPASS_LICENSE_CHECK=${QTFRAMEWORK_BYPASS_LICENSE_CHECK:-<unset>}"
          
          # Hard guards to fail fast if environment regresses
          if [[ -z "${CMAKE_PREFIX_PATH:-}" ]]; then
            echo "❌ CMAKE_PREFIX_PATH is empty"; exit 1
          fi
          if [[ "${QT_VERSION:-}" != "6.10.0" ]]; then
            echo "❌ QT_VERSION must be 6.10.0, got: ${QT_VERSION:-<unset>}"; exit 1
          fi
          if [[ "${QTFRAMEWORK_BYPASS_LICENSE_CHECK:-}" != "1" ]]; then
            echo "❌ QTFRAMEWORK_BYPASS_LICENSE_CHECK must be 1, got: ${QTFRAMEWORK_BYPASS_LICENSE_CHECK:-<unset>}"; exit 1
          fi

      - name: Guard - no stale LogCategories includes
        run: |
          if git grep -n 'LogCategories.h' -- 'src/**' ; then
            echo "❌ Found stale include of LogCategories.h"; exit 1;
          fi

      - name: Qt probe
        shell: bash
        run: |
          set -e
          echo "CMAKE_PREFIX_PATH=$CMAKE_PREFIX_PATH"
          if [[ -z "$CMAKE_PREFIX_PATH" ]]; then
            echo "❌ CMAKE_PREFIX_PATH not set"
            exit 1
          fi
          if [[ ! -f "$CMAKE_PREFIX_PATH/lib/cmake/Qt6/Qt6Config.cmake" ]]; then
            echo "❌ Qt6Config.cmake not found at $CMAKE_PREFIX_PATH/lib/cmake/Qt6/Qt6Config.cmake"
            exit 1
          fi
          echo "✅ Qt probe OK: $CMAKE_PREFIX_PATH"

      - name: Clean configure
        run: |
          rm -rf build/dev-01-relwithdebinfo
          cmake -S . -B build/dev-01-relwithdebinfo -G "Ninja" \
            -DCMAKE_BUILD_TYPE=RelWithDebInfo \
            -DCMAKE_PREFIX_PATH="$CMAKE_PREFIX_PATH"

      - name: Build
        run: cmake --build build/dev-01-relwithdebinfo -j $(nproc || echo 4)
        continue-on-error: false

      - name: Unit tests
        if: hashFiles('build/dev-01-relwithdebinfo/CTestTestfile.cmake') != ''
        run: ctest --test-dir build/dev-01-relwithdebinfo --output-on-failure
        continue-on-error: false

  ci_checks:
    needs: changes
    if: github.event_name == 'pull_request' && needs.changes.outputs.ci_only == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
      - name: Guard - no conflict markers in workflows
        run: |
          if grep -R -nE '^<<<<<<<|^>>>>>>>' .github/workflows ; then
            echo "❌ Conflict markers found in workflow files"; exit 1;
          fi
      - name: Lint workflows
        uses: ibiqlik/action-yamllint@v3
        with:
          file_or_dir: .github/workflows
          config_file: .yamllint.yml

  palantir-no-blocking-when-disabled:
    name: Palantir: block new blocking calls when disabled
    runs-on: ubuntu-latest
    env:
      PHX_WITH_PALANTIR: '0'   # Sprint 4 default
    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Compute diff vs base
        id: diff
        run: |
          # Determine base reference for PRs and pushes
          if [ -n "${GITHUB_BASE_REF}" ]; then
            BASE="origin/${GITHUB_BASE_REF}"
          else
            BASE="$(git rev-parse origin/main || echo HEAD~1)"
          fi
          echo "BASE_REF=${BASE}" >> $GITHUB_OUTPUT

      - name: Scan diff for blocking patterns (only when Palantir disabled)
        if: ${{ env.PHX_WITH_PALANTIR == '0' }}
        run: |
          BASE_REF="${{ steps.diff.outputs.BASE_REF }}"
          # Filter to palantir sources and only added/changed hunks
          DIFF=$(git diff --unified=0 --diff-filter=ACMRT "$BASE_REF"...HEAD -- src/palantir || true)
          # Patterns to catch (function names and sleeps)
          if echo "$DIFF" | grep -E '^\+.*\b(waitFor[A-Za-z]*|sleep\(|msleep\(|usleep\()' ; then
            echo "::error ::New blocking call(s) added under src/palantir while PHX_WITH_PALANTIR=OFF."
            exit 1
          else
            echo "No new blocking calls found in src/palantir."
          fi

  gate:
    needs: [changes, docs, build, ci_checks, palantir-no-blocking-when-disabled, pre-build-checks]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Decide outcome (Gate)
        shell: bash
        run: |
          set -euo pipefail
          echo "docs_only=${{ needs.changes.outputs.docs_only }}"
          echo "code_changed=${{ needs.changes.outputs.code_changed }}"
          echo "ci_only=${{ needs.changes.outputs.ci_only }}"
          echo "docs=${{ needs.docs.result || 'skipped' }}"
          echo "build=${{ needs.build.result || 'skipped' }}"
          echo "ci=${{ needs.ci_checks.result || 'skipped' }}"

          if [[ "${{ needs.changes.outputs.ci_only }}" == "true" ]]; then
            [[ "${{ needs.ci_checks.result }}" == "success" ]] || { echo "CI checks failed"; exit 1; }
            echo "✅ Gate: CI-only path passed."; exit 0
          fi

          if [[ "${{ needs.changes.outputs.docs_only }}" == "true" ]]; then
            [[ "${{ needs.docs.result }}" == "success" ]] || { echo "Docs checks failed"; exit 1; }
            echo "✅ Gate: docs-only path passed."; exit 0
          fi

          if [[ "${{ needs.changes.outputs.code_changed }}" == "true" ]]; then
            [[ "${{ needs.build.result }}" == "success" ]] || { echo "Build failed"; exit 1; }
            echo "✅ Gate: code path passed."; exit 0
          fi

          echo "ℹ️ Gate: no docs/code/ci matched; treating as pass."; exit 0