name: CI

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
    branches: [ main ]        # ensure main is included
  push:
    branches: [ main ]        # always build on main pushes
  workflow_dispatch:
    inputs:
      pr:
        description: 'PR number (optional)'
        required: false
      soak:
        description: 'Run soak harness (empty, quick, 1h, 2h)'
        required: false
        default: ''
  schedule:
    - cron: "0 9 * * 1"       # every Monday 09:00 UTC - weekly self-audit
    - cron: "0 3 * * *"       # nightly soak harness (03:00 UTC)

permissions:
  contents: read
  pull-requests: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  pre-build-checks:
    name: Pre-build resource checks
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
      
      - name: Validate QRC entries
        run: |
          set -e
          QRC_FILE="src/ui/icons/phoenix_icons.qrc"
          if [ ! -f "$QRC_FILE" ]; then
            echo "❌ QRC file not found: $QRC_FILE"
            exit 1
          fi
          
          # Extract file paths from QRC using sed to parse XML
          QRC_DIR="$(dirname "$QRC_FILE")"
          while IFS= read -r line; do
            # Extract path between > and </file>
            file_path=$(echo "$line" | sed -n 's/.*>\(.*\)<\/file>/\1/p')
            if [ -n "$file_path" ]; then
              # Resolve relative path from qrc location
              full_path="$QRC_DIR/$file_path"
              if [ ! -f "$full_path" ]; then
                echo "❌ QRC entry points to missing file: $file_path (resolved: $full_path)"
                exit 1
              fi
            fi
          done < <(grep '<file' "$QRC_FILE")
          
          echo "✅ All QRC entries validated"
      
      - name: Check SVG currentColor usage
        run: |
          set -e
          # Check non-branding SVGs for hardcoded colors
          # Branding SVGs (phoenix-icon.svg) are exempt
          SVG_DIR="assets/icons/fontawesome-pro/svgs"
          if [ ! -d "$SVG_DIR" ]; then
            echo "⚠️  SVG directory not found, skipping check"
            exit 0
          fi
          
          # Find SVGs with hardcoded fill or stroke (excluding branding)
          VIOLATIONS=$(find "$SVG_DIR" -name "*.svg" ! -name "*phoenix*" -exec grep -l 'fill="#[^c]' {} \; 2>/dev/null || true)
          if [ -n "$VIOLATIONS" ]; then
            echo "❌ Found SVGs with hardcoded fill colors (should use fill=\"currentColor\"):"
            echo "$VIOLATIONS"
            exit 1
          fi
          
          VIOLATIONS=$(find "$SVG_DIR" -name "*.svg" ! -name "*phoenix*" -exec grep -l 'stroke="#[^c]' {} \; 2>/dev/null || true)
          if [ -n "$VIOLATIONS" ]; then
            echo "❌ Found SVGs with hardcoded stroke colors (should use stroke=\"currentColor\"):"
            echo "$VIOLATIONS"
            exit 1
          fi
          
          echo "✅ SVG color check passed"

  changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      docs_only: ${{ steps.classify.outputs.docs_only }}
      code_changed: ${{ steps.classify.outputs.code_changed }}
      ci_only: ${{ steps.classify.outputs.ci_only }}
    steps:
      - name: Checkout (full history)
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          # For PRs, point at the head ref explicitly to avoid shallow/detached surprises
          ref: ${{ github.event.pull_request.head.sha || github.sha }}

      # Guard: no conflict markers in workflows
      - name: Guard - no conflict markers in workflows
        run: |
          if grep -R -nE '^<<<<<<<|^>>>>>>>' .github/workflows ; then
            echo "❌ Conflict markers found in workflow files"; exit 1;
          fi

      # Lint workflows (temporarily disabled to get CI working)
      # - name: Lint workflows
      #   uses: ibiqlik/action-yamllint@v3
      #   with:
      #     file_or_dir: .github/workflows
      #     config_file: .yamllint.yml

      - name: Detect changed paths
        id: filter
        uses: dorny/paths-filter@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          filters: |
            docs:
              - 'docs/**'
              - '**/*.md'
              - 'assets/docs/**'
              - 'docs-assets/**'
            code:
              - 'src/**'
              - 'cmake/**'
              - 'CMakeLists.txt'
              - '**/*.{cpp,cxx,c,h,hpp,ui,qrc,qml,rc,ico,icns}'
            ci:
              - '.github/workflows/**'

      # OPTIONAL but hugely helpful: print what matched
      - name: Debug - show classification
        shell: bash
        run: |
          echo "docs=${{ steps.filter.outputs.docs }}"
          echo "code=${{ steps.filter.outputs.code }}"
          echo "ci=${{ steps.filter.outputs.ci }}"
          echo "docs_files:"
          echo "${{ steps.filter.outputs.docs_files }}"
          echo "code_files:"
          echo "${{ steps.filter.outputs.code_files }}"
          echo "ci_files:"
          echo "${{ steps.filter.outputs.ci_files }}"

      - name: Classify (docs/code/ci)
        id: classify
        shell: bash
        run: |
          set -euo pipefail
          docs="${{ steps.filter.outputs.docs }}"
          code="${{ steps.filter.outputs.code }}"
          ci="${{ steps.filter.outputs.ci }}"

          # NEW: handle "no matched files" (avoid kicking off a build)
          if [[ "$docs" == "false" && "$code" == "false" && "$ci" == "false" ]]; then
            echo "docs_only=false"     >>"$GITHUB_OUTPUT"
            echo "code_changed=false"  >>"$GITHUB_OUTPUT"
            echo "ci_only=false"       >>"$GITHUB_OUTPUT"
            exit 0
          fi

          if [[ "$docs" == "true" && "$code" == "false" && "$ci" == "false" ]]; then
            echo "docs_only=true"      >>"$GITHUB_OUTPUT"
            echo "code_changed=false"  >>"$GITHUB_OUTPUT"
            echo "ci_only=false"       >>"$GITHUB_OUTPUT"
          elif [[ "$ci" == "true" && "$code" == "false" && "$docs" == "false" ]]; then
            echo "docs_only=false"     >>"$GITHUB_OUTPUT"
            echo "code_changed=false"  >>"$GITHUB_OUTPUT"
            echo "ci_only=true"        >>"$GITHUB_OUTPUT"
          else
            echo "docs_only=false"     >>"$GITHUB_OUTPUT"
            echo "code_changed=true"   >>"$GITHUB_OUTPUT"
            echo "ci_only=false"       >>"$GITHUB_OUTPUT"
          fi

  docs:
    needs: changes
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && needs.changes.outputs.docs_only == 'true'
    steps:
      - uses: actions/checkout@v5
      - uses: DavidAnson/markdownlint-cli2-action@v20
        with:
          globs: |
            **/*.md
            !.github/**
            !.underlord/**
            !docs/palantir/**
            !assets/**
            !ci-audit-package/**
            !CHANGELOG.md
      - name: link check
        uses: lycheeverse/lychee-action@v2   # pin to v1 while stabilizing
        with:
          args: >
            --no-progress --include-fragments
            --max-concurrency 4 --max-redirects 5
            --retry-wait-time 2 --retry-count 1 --timeout 20
            --accept 200,206 .
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - uses: codespell-project/actions-codespell@v2
        with:
          path: docs .
          skip: .git,build

  build:
    name: Build + Tests
    needs: changes
    timeout-minutes: 30
    if: >
      (github.event_name == 'push') ||
      (github.event_name == 'pull_request' &&
       github.event.pull_request.head.repo.full_name == github.repository &&
       needs.changes.outputs.code_changed == 'true')
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
    runs-on: ${{ matrix.os }}
    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}
      cancel-in-progress: true
    env:
      QT_VERSION: 6.10.1
      QTFRAMEWORK_BYPASS_LICENSE_CHECK: "1"
    steps:
      - uses: actions/checkout@v5
        with:
          submodules: recursive
      
      - name: Verify contracts submodule SHA parity
        run: |
          expected=$(cat .contract-version)
          actual=$(git -C contracts rev-parse HEAD)
          
          echo "Expected contracts SHA: $expected"
          echo "Actual   contracts SHA: $actual"
          
          if [ "$expected" != "$actual" ]; then
            echo "ERROR: Contract SHA mismatch."
            echo "Expected: $expected"
            echo "Actual:   $actual"
            echo "Fix: update contracts/ or .contract-version in a coordinated change."
            exit 1
          fi
          echo "✅ Contracts SHA parity check passed"
      
      - name: Guard - no stale LogCategories includes
        run: |
          if git grep -n 'LogCategories.h' -- 'src/**' ; then
            echo "❌ Found stale include of LogCategories.h"; exit 1;
          fi

      - name: Install Qt 6.10.1
        uses: jurplel/install-qt-action@v3
        with:
          version: '6.10.1'
          modules: 'qtbase qttools qttranslations qtgraphs qtgraphswidgets'
          cache: true

      - name: Verify Qt installation
        run: |
          set -e
          # install-qt-action sets Qt6_DIR to the Qt installation path
          if [[ -z "$Qt6_DIR" ]]; then
            echo "❌ Qt6_DIR not set by install-qt-action"
            exit 1
          fi
          # Qt6_DIR points to the directory containing Qt6Config.cmake
          if [[ ! -f "$Qt6_DIR/Qt6Config.cmake" ]]; then
            echo "❌ Qt6Config.cmake not found at $Qt6_DIR/Qt6Config.cmake"
            exit 1
          fi
          echo "✅ Qt installation verified: $Qt6_DIR"
          echo "Qt6_DIR=$Qt6_DIR" >> $GITHUB_ENV
          # CMAKE_PREFIX_PATH should point to the parent directory
          CMAKE_PREFIX_PATH=$(dirname "$Qt6_DIR")
          echo "CMAKE_PREFIX_PATH=$CMAKE_PREFIX_PATH" >> $GITHUB_ENV
          echo "Using CMAKE_PREFIX_PATH=$CMAKE_PREFIX_PATH"

      - name: Clean configure
        run: |
          rm -rf build/relwithdebinfo
          # Enable coverage on Linux only
          if [[ "${{ matrix.os }}" == "ubuntu-latest" ]]; then
            COVERAGE_FLAGS="-fprofile-arcs -ftest-coverage --coverage"
          else
            COVERAGE_FLAGS=""
          fi
          cmake -S . -B build/relwithdebinfo -G "Ninja" \
            -DCMAKE_BUILD_TYPE=RelWithDebInfo \
            -DCMAKE_PREFIX_PATH="$CMAKE_PREFIX_PATH" \
            -DCMAKE_CXX_FLAGS="$COVERAGE_FLAGS" \
            -DCMAKE_EXE_LINKER_FLAGS="$COVERAGE_FLAGS" \
            -DPHX_WITH_TRANSPORT_DEPS=ON \
            -DBUILD_TESTING=ON

      - name: Build
        run: cmake --build build/relwithdebinfo -j $(nproc || echo 4)
        continue-on-error: false

      - name: Translation drift guard
        run: ./ci/check_translations.sh build/relwithdebinfo

      - name: Run all tests (ctest)
        if: hashFiles('build/relwithdebinfo/CTestTestfile.cmake') != ''
        run: ctest --test-dir build/relwithdebinfo --output-on-failure
        continue-on-error: false

      - name: Install lcov (Linux only)
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y lcov

      - name: Generate coverage report (Linux only)
        if: matrix.os == 'ubuntu-latest'
        run: |
          cd build/relwithdebinfo
          # Capture coverage data
          lcov --directory . --capture --output-file coverage.info
          
          # Remove system headers, external libs, and test files
          # Focus on src/transport/* and src/analysis/RemoteExecutor*
          lcov --remove coverage.info \
            '/usr/*' \
            '*/tests/*' \
            '*/build/*' \
            '*/generated/*' \
            '*/contracts/*' \
            --output-file coverage-filtered.info
          
          # Generate HTML report
          genhtml coverage-filtered.info \
            --output-directory coverage-html \
            --prefix "$(pwd)/../.." \
            --show-details \
            --legend \
            --demangle-cpp
          
          # Print summary
          echo "=== Coverage Summary ==="
          lcov --summary coverage-filtered.info || true
          
          # Print coverage for Palantir-related paths
          echo ""
          echo "=== Palantir-Related Coverage ==="
          lcov --summary coverage-filtered.info | grep -E "(src/transport|src/analysis)" || echo "No Palantir paths found in coverage"

      - name: Upload coverage report (Linux only)
        if: matrix.os == 'ubuntu-latest'
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report-phoenix
          path: |
            build/relwithdebinfo/coverage-html/**
            build/relwithdebinfo/coverage-filtered.info
          retention-days: 30

  ci_checks:
    needs: changes
    if: github.event_name == 'pull_request' && needs.changes.outputs.ci_only == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
      - name: Guard - no conflict markers in workflows
        run: |
          if grep -R -nE '^<<<<<<<|^>>>>>>>' .github/workflows ; then
            echo "❌ Conflict markers found in workflow files"; exit 1;
          fi
      - name: Lint workflows
        uses: ibiqlik/action-yamllint@v3
        with:
          file_or_dir: .github/workflows
          config_file: .yamllint.yml

  palantir-no-blocking-when-disabled:
    name: Palantir: block new blocking calls when disabled
    runs-on: ubuntu-latest
    env:
      PHX_WITH_PALANTIR: '0'   # Sprint 4 default
    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Compute diff vs base
        id: diff
        run: |
          # Determine base reference for PRs and pushes
          if [ -n "${GITHUB_BASE_REF}" ]; then
            BASE="origin/${GITHUB_BASE_REF}"
          else
            BASE="$(git rev-parse origin/main || echo HEAD~1)"
          fi
          echo "BASE_REF=${BASE}" >> $GITHUB_OUTPUT

      - name: Scan diff for blocking patterns (only when Palantir disabled)
        if: ${{ env.PHX_WITH_PALANTIR == '0' }}
        run: |
          BASE_REF="${{ steps.diff.outputs.BASE_REF }}"
          # Filter to palantir sources and only added/changed hunks
          DIFF=$(git diff --unified=0 --diff-filter=ACMRT "$BASE_REF"...HEAD -- src/palantir || true)
          # Patterns to catch (function names and sleeps)
          if echo "$DIFF" | grep -E '^\+.*\b(waitFor[A-Za-z]*|sleep\(|msleep\(|usleep\()' ; then
            echo "::error ::New blocking call(s) added under src/palantir while PHX_WITH_PALANTIR=OFF."
            exit 1
          else
            echo "No new blocking calls found in src/palantir."
          fi

  soak-nightly:
    name: Soak (Linux 30m)
    if: github.event_name == 'schedule' && github.event.schedule == '0 3 * * *'
    runs-on: ubuntu-latest
    timeout-minutes: 120
    env:
      QT_VERSION: 6.10.1
      QTFRAMEWORK_BYPASS_LICENSE_CHECK: "1"
    steps:
      - uses: actions/checkout@v5
        with:
          submodules: recursive
      
      - name: Install Qt 6.10.1
        uses: jurplel/install-qt-action@v3
        with:
          version: '6.10.1'
          modules: 'qtbase qttools qttranslations qtgraphs qtgraphswidgets'
          cache: true
      
      - name: Setup Qt environment
        run: |
          if [[ -z "$Qt6_DIR" ]]; then
            echo "❌ Qt6_DIR not set by install-qt-action"
            exit 1
          fi
          CMAKE_PREFIX_PATH=$(dirname "$Qt6_DIR")
          echo "CMAKE_PREFIX_PATH=$CMAKE_PREFIX_PATH" >> $GITHUB_ENV
      
      - name: Build soak binary
        run: make soak-build
      - name: Run soak (30 minutes)
        run: make soak-quick
      - name: Upload soak artifacts
        uses: actions/upload-artifact@v4
        with:
          name: soak-linux-30m-${{ github.run_id }}
          path: |
            /tmp/phoenix_soak_app.log
            /tmp/phoenix_soak_memory.csv

  soak-macos-weekly:
    name: Soak (macOS weekly)
    if: github.event_name == 'schedule' && github.event.schedule == '0 9 * * 1'
    runs-on: [self-hosted, macOS, X64, qt6]
    timeout-minutes: 180
    steps:
      - uses: actions/checkout@v5
      - name: Build soak binary
        run: make soak-build
      - name: Run soak (60 minutes)
        run: make soak-1h
      - name: Upload soak artifacts
        uses: actions/upload-artifact@v4
        with:
          name: soak-macos-60m-${{ github.run_id }}
          path: |
            /tmp/phoenix_soak_app.log
            /tmp/phoenix_soak_memory.csv

  soak-release:
    name: Soak (Linux 60m)
    if: |
      (github.event_name == 'workflow_dispatch' && github.event.inputs.soak == '1h') ||
      (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/phoenix-sprint'))
    runs-on: ubuntu-latest
    timeout-minutes: 180
    env:
      QT_VERSION: 6.10.1
      QTFRAMEWORK_BYPASS_LICENSE_CHECK: "1"
    steps:
      - uses: actions/checkout@v5
        with:
          submodules: recursive
      
      - name: Install Qt 6.10.1
        uses: jurplel/install-qt-action@v3
        with:
          version: '6.10.1'
          modules: 'qtbase qttools qttranslations qtgraphs qtgraphswidgets'
          cache: true
      
      - name: Setup Qt environment
        run: |
          if [[ -z "$Qt6_DIR" ]]; then
            echo "❌ Qt6_DIR not set by install-qt-action"
            exit 1
          fi
          CMAKE_PREFIX_PATH=$(dirname "$Qt6_DIR")
          echo "CMAKE_PREFIX_PATH=$CMAKE_PREFIX_PATH" >> $GITHUB_ENV
      
      - name: Build soak binary
        run: make soak-build
      - name: Run soak (60 minutes)
        run: make soak-1h
      - name: Upload soak artifacts
        uses: actions/upload-artifact@v4
        with:
          name: soak-linux-60m-${{ github.run_id }}
          path: |
            /tmp/phoenix_soak_app.log
            /tmp/phoenix_soak_memory.csv

  gate:
    needs: [changes, docs, build, ci_checks, palantir-no-blocking-when-disabled, pre-build-checks]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Decide outcome (Gate)
        shell: bash
        run: |
          set -euo pipefail
          echo "docs_only=${{ needs.changes.outputs.docs_only }}"
          echo "code_changed=${{ needs.changes.outputs.code_changed }}"
          echo "ci_only=${{ needs.changes.outputs.ci_only }}"
          echo "docs=${{ needs.docs.result || 'skipped' }}"
          echo "build=${{ needs.build.result || 'skipped' }}"
          echo "ci=${{ needs.ci_checks.result || 'skipped' }}"

          if [[ "${{ needs.changes.outputs.ci_only }}" == "true" ]]; then
            [[ "${{ needs.ci_checks.result }}" == "success" ]] || { echo "CI checks failed"; exit 1; }
            echo "✅ Gate: CI-only path passed."; exit 0
          fi

          if [[ "${{ needs.changes.outputs.docs_only }}" == "true" ]]; then
            [[ "${{ needs.docs.result }}" == "success" ]] || { echo "Docs checks failed"; exit 1; }
            echo "✅ Gate: docs-only path passed."; exit 0
          fi

          if [[ "${{ needs.changes.outputs.code_changed }}" == "true" ]]; then
            # Build job now runs on matrix (ubuntu + macos), check both succeeded
            if [[ "${{ needs.build.result }}" != "success" ]]; then
              echo "Build failed (one or more matrix jobs failed)"
              exit 1
            fi
            echo "✅ Gate: code path passed."; exit 0
          fi

          echo "ℹ️ Gate: no docs/code/ci matched; treating as pass."; exit 0